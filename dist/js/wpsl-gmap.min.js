/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./js/wpsl-gmap.js":
/*!*************************!*\
  !*** ./js/wpsl-gmap.js ***!
  \*************************/
/***/ (() => {

eval("var wpsl = wpsl || {};\nwpsl.gmaps = {};\n/**\r\n * This is only used to init the map after the\r\n * user agreed to load Google Maps in combination\r\n * with the Borlabs Cookie plugin.\r\n *\r\n * @since 2.2.22\r\n * @returns {void}\r\n */\n\nfunction initWpslMap() {\n  var mapsLoaded;\n  mapsLoaded = setInterval(function () {\n    if (typeof google === \"object\" && typeof google.maps === \"object\") {\n      clearInterval(mapsLoaded);\n      jQuery(\".wpsl-gmap-canvas\").each(function (mapIndex) {\n        var mapId = jQuery(this).attr(\"id\");\n        wpsl.gmaps.init(mapId, mapIndex);\n      });\n    }\n  }, 500);\n}\n\njQuery(document).ready(function ($) {\n  var geocoder,\n      map,\n      directionsDisplay,\n      directionsService,\n      autoCompleteLatLng,\n      activeWindowMarkerId,\n      infoWindow,\n      markerClusterer,\n      startMarkerData,\n      startAddress,\n      openInfoWindow = [],\n      markersArray = [],\n      mapsArray = [],\n      markerSettings = {},\n      directionMarkerPosition = {},\n      mapDefaults = {},\n      resetMap = false,\n      streetViewAvailable = false,\n      autoLoad = typeof wpslSettings !== \"undefined\" ? wpslSettings.autoLoad : \"\",\n      userGeolocation = {},\n      statistics = {\n    enabled: typeof wpslSettings.collectStatistics !== \"undefined\" ? true : false,\n    addressComponents: \"\"\n  };\n  /**\r\n   * Set the underscore template settings.\r\n   *\r\n   * Defining them here prevents other plugins\r\n   * that also use underscore / backbone, and defined a\r\n   * different _.templateSettings from breaking the\r\n   * rendering of the store locator template.\r\n   *\r\n   * @link\t http://underscorejs.org/#template\r\n   * @requires underscore.js\r\n   * @since\t 2.0.0\r\n   */\n\n  _.templateSettings = {\n    evaluate: /\\<\\%(.+?)\\%\\>/g,\n    interpolate: /\\<\\%=(.+?)\\%\\>/g,\n    escape: /\\<\\%-(.+?)\\%\\>/g\n  };\n  /**\r\n   * Initialize Google Maps with the correct settings.\r\n   *\r\n   * @since   1.0.0\r\n   * @param   {string} mapId    The id of the map div\r\n   * @param   {number} mapIndex Number of the map\r\n   * @returns {void}\r\n   */\n\n  wpsl.gmaps.init = function (mapId, mapIndex) {\n    var mapOptions,\n        mapDetails,\n        settings,\n        infoWindow,\n        latLng,\n        bounds,\n        mapData,\n        zoomLevel,\n        defaultZoomLevel = Number(wpslSettings.zoomLevel),\n        maxZoom = Number(wpslSettings.autoZoomLevel); // Get the settings that belongs to the current map.\n\n    settings = getMapSettings(mapIndex);\n    /*\r\n     * This is the value from either the settings page,\r\n     * or the zoom level set through the shortcode.\r\n     */\n\n    zoomLevel = Number(settings.zoomLevel);\n    /*\r\n     * If they are not equal, then the zoom value is set through the shortcode.\r\n     * If this is the case, then we use that as the max zoom level.\r\n     */\n\n    if (zoomLevel !== defaultZoomLevel) {\n      maxZoom = zoomLevel;\n    } // Create a new infoWindow, either with the infobox libray or use the default one.\n\n\n    infoWindow = newInfoWindow();\n    geocoder = new google.maps.Geocoder();\n    directionsDisplay = new google.maps.DirectionsRenderer();\n    directionsService = new google.maps.DirectionsService(); // Set the map options.\n\n    mapOptions = {\n      zoom: zoomLevel,\n      center: settings.startLatLng,\n      mapTypeId: google.maps.MapTypeId[settings.mapType.toUpperCase()],\n      mapTypeControl: Number(settings.mapTypeControl) ? true : false,\n      streetViewControl: Number(settings.streetView) ? true : false,\n      gestureHandling: settings.gestureHandling,\n      zoomControlOptions: {\n        position: google.maps.ControlPosition[settings.controlPosition.toUpperCase() + \"_TOP\"]\n      }\n    };\n    /**\r\n     * When the gestureHandling is set to cooperative and the scrollWheel\r\n     * options is also set, then the gestureHandling value is ingored.\r\n     *\r\n     * To fix this we only include the scrollWheel options when 'cooperative' isn't used.\r\n     */\n\n    if (settings.gestureHandling !== \"cooperative\") {\n      mapOptions.scrollwheel = Number(settings.scrollWheel) ? true : false;\n    } // Get the correct marker path & properties.\n\n\n    markerSettings = getMarkerSettings();\n    map = new google.maps.Map(document.getElementById(mapId), mapOptions); // Check if we need to apply a map style.\n\n    maybeApplyMapStyle(settings.mapStyle);\n\n    if (typeof window[\"wpslMap_\" + mapIndex] !== \"undefined\" && typeof window[\"wpslMap_\" + mapIndex].locations !== \"undefined\") {\n      bounds = new google.maps.LatLngBounds(), mapData = window[\"wpslMap_\" + mapIndex].locations; // Loop over the map data, create the infowindow object and add each marker.\n\n      $.each(mapData, function (index) {\n        latLng = new google.maps.LatLng(mapData[index].lat, mapData[index].lng);\n        addMarker(latLng, mapData[index].id, mapData[index], false, infoWindow);\n        bounds.extend(latLng);\n      }); // If we have more then one location on the map, then make sure to not zoom to far.\n\n      if (mapData.length > 1) {\n        // Make sure we don't zoom to far when fitBounds runs.\n        attachBoundsChangedListener(map, maxZoom); // Make all the markers fit on the map.\n\n        map.fitBounds(bounds);\n      }\n      /*\r\n       * If we need to apply the fix for the map showing up grey because\r\n       * it's used in a tabbed nav multiple times, then collect the active maps.\r\n       *\r\n       * See the fixGreyTabMap function.\r\n       */\n\n\n      if (_.isArray(wpslSettings.mapTabAnchor)) {\n        mapDetails = {\n          map: map,\n          bounds: bounds,\n          maxZoom: maxZoom\n        };\n        mapsArray.push(mapDetails);\n      }\n    } // Only run this part if the store locator exist and we don't just have a basic map.\n\n\n    if ($(\"#wpsl-gmap\").length) {\n      if (wpslSettings.autoComplete == 1) {\n        activateAutocomplete();\n      }\n      /*\r\n       * Not the most optimal solution, but we check the useragent if we should enable the styled dropdowns.\r\n       *\r\n       * We do this because several people have reported issues with the styled dropdowns on\r\n       * iOS and Android devices. So on mobile devices the dropdowns will be styled according\r\n       * to the browser styles on that device.\r\n       */\n\n\n      if (!checkMobileUserAgent() && $(\".wpsl-dropdown\").length && wpslSettings.enableStyledDropdowns == 1) {\n        insertDefaultOption();\n        createDropdowns();\n      } else {\n        $(\"#wpsl-search-wrap select\").show();\n\n        if (checkMobileUserAgent()) {\n          $(\"#wpsl-wrap\").addClass(\"wpsl-mobile\");\n          insertDefaultOption();\n        } else {\n          $(\"#wpsl-wrap\").addClass(\"wpsl-default-filters\");\n        }\n      } // Check if we need to autolocate the user, or autoload the store locations.\n\n\n      if (!$(\".wpsl-search\").hasClass(\"wpsl-widget\")) {\n        if (wpslSettings.autoLocate == 1) {\n          checkGeolocation(settings.startLatLng, infoWindow);\n        } else if (wpslSettings.autoLoad == 1) {\n          showStores(settings.startLatLng, infoWindow);\n        }\n      } // Move the mousecursor to the store search field if the focus option is enabled.\n\n\n      if (wpslSettings.mouseFocus == 1 && !checkMobileUserAgent()) {\n        $(\"#wpsl-search-input\").focus();\n      } // Bind store search button.\n\n\n      searchLocationBtn(infoWindow); // Add the 'reload' and 'find location' icon to the map.\n\n      mapControlIcons(settings, map, infoWindow); // Check if the user submitted a search through a search widget.\n\n      checkWidgetSubmit();\n    } // Bind the zoom_changed listener.\n\n\n    zoomChangedListener();\n  }; // Only continue if a map is present.\n\n\n  if ($(\".wpsl-gmap-canvas\").length) {\n    $(\"<img />\").attr(\"src\", wpslSettings.url + \"img/ajax-loader.gif\");\n    /*\r\n     * The [wpsl] shortcode can only exist once on a page,\r\n     * but the [wpsl_map] shortcode can exist multiple times.\r\n     *\r\n     * So to make sure we init all the maps we loop over them.\r\n     */\n\n    $(\".wpsl-gmap-canvas\").each(function (mapIndex) {\n      var mapId = $(this).attr(\"id\");\n      wpsl.gmaps.init(mapId, mapIndex);\n    });\n    /*\r\n     * Check if we are dealing with a map that's placed in a tab,\r\n     * if so run a fix to prevent the map from showing up grey.\r\n     */\n\n    maybeApplyTabFix();\n  }\n  /**\r\n   * Activate the autocomplete for the store search.\r\n   *\r\n   * @since 2.2.0\r\n   * @link https://developers.google.com/maps/documentation/javascript/places-autocomplete\r\n   * @returns {void}\r\n   */\n\n\n  function activateAutocomplete() {\n    var input,\n        autocomplete,\n        place,\n        options = {}; // Handle autocomplete queries submitted by the user using the 'enter' key.\n\n    keyboardAutoCompleteSubmit();\n    /**\r\n     * Check if we need to set the geocode component restrictions.\r\n     * This is automatically included when a fixed map region is\r\n     * selected on the WPSL settings page.\r\n     */\n\n    if (typeof wpslSettings.geocodeComponents !== \"undefined\" && !$.isEmptyObject(wpslSettings.geocodeComponents)) {\n      options.componentRestrictions = wpslSettings.geocodeComponents;\n      /**\r\n       * If the postalCode is included in the autocomplete together with '(regions)' ( which is included ),\r\n       * then it will break it. So we have to remove it.\r\n       */\n\n      options.componentRestrictions = _.omit(options.componentRestrictions, \"postalCode\");\n    } // Check if we need to restrict the autocomplete data.\n\n\n    if (typeof wpslSettings.autoCompleteOptions !== \"undefined\" && !$.isEmptyObject(wpslSettings.autoCompleteOptions)) {\n      for (var key in wpslSettings.autoCompleteOptions) {\n        if (wpslSettings.autoCompleteOptions.hasOwnProperty(key)) {\n          options[key] = wpslSettings.autoCompleteOptions[key];\n        }\n      }\n    }\n\n    input = document.getElementById(\"wpsl-search-input\");\n    autocomplete = new google.maps.places.Autocomplete(input, options);\n    autocomplete.addListener(\"place_changed\", function () {\n      place = autocomplete.getPlace();\n      /**\r\n       * Assign the returned latlng to the autoCompleteLatLng var.\r\n       * This var is used when the users submits the search.\r\n       */\n\n      if (place.geometry) {\n        autoCompleteLatLng = place.geometry.location;\n      }\n    });\n  }\n  /**\r\n   * Make sure that the 'Zoom here' link in the info window\r\n   * doesn't zoom past the max auto zoom level.\r\n   *\r\n   * The 'max auto zoom level' is set on the settings page.\r\n   *\r\n   * @since   2.0.0\r\n   * @returns {void}\r\n   */\n\n\n  function zoomChangedListener() {\n    if (typeof wpslSettings.markerZoomTo !== \"undefined\" && wpslSettings.markerZoomTo == 1) {\n      google.maps.event.addListener(map, \"zoom_changed\", function () {\n        checkMaxZoomLevel();\n      });\n    }\n  }\n  /**\r\n   * Get the correct map settings.\r\n   *\r\n   * @since\t2.0.0\r\n   * @param\t{number} mapIndex    Number of the map\r\n   * @returns {object} mapSettings The map settings either set through a shortcode or the default settings\r\n   */\n\n\n  function getMapSettings(mapIndex) {\n    var j,\n        len,\n        shortCodeVal,\n        settingOptions = [\"zoomLevel\", \"mapType\", \"mapTypeControl\", \"mapStyle\", \"streetView\", \"scrollWheel\", \"controlPosition\"],\n        mapSettings = {\n      zoomLevel: wpslSettings.zoomLevel,\n      mapType: wpslSettings.mapType,\n      mapTypeControl: wpslSettings.mapTypeControl,\n      mapStyle: wpslSettings.mapStyle,\n      streetView: wpslSettings.streetView,\n      scrollWheel: wpslSettings.scrollWheel,\n      controlPosition: wpslSettings.controlPosition,\n      gestureHandling: wpslSettings.gestureHandling\n    }; // If there are settings that are set through the shortcode, then we use them instead of the default ones.\n\n    if (typeof window[\"wpslMap_\" + mapIndex] !== \"undefined\" && typeof window[\"wpslMap_\" + mapIndex].shortCode !== \"undefined\") {\n      for (j = 0, len = settingOptions.length; j < len; j++) {\n        shortCodeVal = window[\"wpslMap_\" + mapIndex].shortCode[settingOptions[j]]; // If the value is set through the shortcode, we overwrite the default value.\n\n        if (typeof shortCodeVal !== \"undefined\") {\n          mapSettings[settingOptions[j]] = shortCodeVal;\n        }\n      }\n    }\n\n    mapSettings.startLatLng = getStartLatlng(mapIndex);\n    return mapSettings;\n  }\n  /**\r\n   * Get the latlng coordinates that are used to init the map.\r\n   *\r\n   * @since\t2.0.0\r\n   * @param\t{number} mapIndex    Number of the map\r\n   * @returns {object} startLatLng The latlng value where the map will initially focus on\r\n   */\n\n\n  function getStartLatlng(mapIndex) {\n    var startLatLng,\n        latLng,\n        firstLocation = \"\";\n    /*\r\n     * Maps that are added with the [wpsl_map] shortcode will have the locations key set.\r\n     * If it exists we use the coordinates from the first location to center the map on.\r\n     */\n\n    if (typeof window[\"wpslMap_\" + mapIndex] !== \"undefined\" && typeof window[\"wpslMap_\" + mapIndex].locations !== \"undefined\") {\n      firstLocation = window[\"wpslMap_\" + mapIndex].locations[0];\n    }\n    /*\r\n     * Either use the coordinates from the first location as the start coordinates\r\n     * or the default start point defined on the settings page.\r\n     *\r\n     * If both are not available we set it to 0,0\r\n     */\n\n\n    if (typeof firstLocation !== \"undefined\" && typeof firstLocation.lat !== \"undefined\" && typeof firstLocation.lng !== \"undefined\") {\n      startLatLng = new google.maps.LatLng(firstLocation.lat, firstLocation.lng);\n    } else if (wpslSettings.startLatlng !== \"\") {\n      latLng = wpslSettings.startLatlng.split(\",\");\n      startLatLng = new google.maps.LatLng(latLng[0], latLng[1]);\n    } else {\n      startLatLng = new google.maps.LatLng(0, 0);\n    }\n\n    return startLatLng;\n  }\n  /**\r\n   * Create a new infoWindow object.\r\n   *\r\n   * Either use the default infoWindow or use the infobox library.\r\n   *\r\n   * @since  2.0.0\r\n   * @return {object} infoWindow The infoWindow object\r\n   */\n\n\n  function newInfoWindow() {\n    var boxClearance,\n        boxPixelOffset,\n        infoBoxOptions = {}; // Do we need to use the infobox script or use the default info windows?\n\n    if (typeof wpslSettings.infoWindowStyle !== \"undefined\" && wpslSettings.infoWindowStyle == \"infobox\") {\n      // See http://google-maps-utility-library-v3.googlecode.com/svn/trunk/infobox/docs/reference.html.\n      boxClearance = wpslSettings.infoBoxClearance.split(\",\");\n      boxPixelOffset = wpslSettings.infoBoxPixelOffset.split(\",\");\n      infoBoxOptions = {\n        alignBottom: true,\n        boxClass: wpslSettings.infoBoxClass,\n        closeBoxMargin: wpslSettings.infoBoxCloseMargin,\n        closeBoxURL: wpslSettings.infoBoxCloseUrl,\n        content: \"\",\n        disableAutoPan: Number(wpslSettings.infoBoxDisableAutoPan) ? true : false,\n        enableEventPropagation: Number(wpslSettings.infoBoxEnableEventPropagation) ? true : false,\n        infoBoxClearance: new google.maps.Size(Number(boxClearance[0]), Number(boxClearance[1])),\n        pixelOffset: new google.maps.Size(Number(boxPixelOffset[0]), Number(boxPixelOffset[1])),\n        zIndex: Number(wpslSettings.infoBoxZindex)\n      };\n      infoWindow = new InfoBox(infoBoxOptions);\n    } else {\n      infoWindow = new google.maps.InfoWindow();\n    }\n\n    return infoWindow;\n  }\n  /**\r\n   * Get the required marker settings.\r\n   *\r\n   * @since  2.1.0\r\n   * @return {object} settings The marker settings.\r\n   */\n\n\n  function getMarkerSettings() {\n    var markerProp,\n        markerProps = wpslSettings.markerIconProps,\n        settings = {}; // Use the correct marker path.\n\n    if (typeof markerProps.url !== \"undefined\") {\n      settings.url = markerProps.url;\n    } else if (typeof markerProps.categoryMarkerUrl !== \"undefined\") {\n      settings.categoryMarkerUrl = markerProps.categoryMarkerUrl;\n    } else if (typeof markerProps.alternateMarkerUrl !== \"undefined\") {\n      settings.alternateMarkerUrl = markerProps.alternateMarkerUrl;\n    } else {\n      settings.url = wpslSettings.url + \"img/markers/\";\n    }\n\n    for (var key in markerProps) {\n      if (markerProps.hasOwnProperty(key)) {\n        markerProp = markerProps[key].split(\",\");\n\n        if (markerProp.length == 2) {\n          settings[key] = markerProp;\n        }\n      }\n    }\n\n    return settings;\n  }\n  /**\r\n   * Check if we have a map style that we need to apply to the map.\r\n   *\r\n   * @since  2.0.0\r\n   * @param  {string} mapStyle The id of the map\r\n   * @return {void}\r\n   */\n\n\n  function maybeApplyMapStyle(mapStyle) {\n    // Make sure the JSON is valid before applying it as a map style.\n    mapStyle = tryParseJSON(mapStyle);\n\n    if (mapStyle) {\n      map.setOptions({\n        styles: mapStyle\n      });\n    }\n  }\n  /**\r\n   * Make sure the JSON is valid.\r\n   *\r\n   * @link   http://stackoverflow.com/a/20392392/1065294\r\n   * @since  2.0.0\r\n   * @param  {string} jsonString The JSON data\r\n   * @return {object|boolean}\tThe JSON string or false if it's invalid json.\r\n   */\n\n\n  function tryParseJSON(jsonString) {\n    try {\n      var o = JSON.parse(jsonString);\n      /*\r\n       * Handle non-exception-throwing cases:\r\n       * Neither JSON.parse(false) or JSON.parse(1234) throw errors, hence the type-checking,\r\n       * but... JSON.parse(null) returns 'null', and typeof null === \"object\",\r\n       * so we must check for that, too.\r\n       */\n\n      if (o && typeof o === \"object\" && o !== null) {\n        return o;\n      }\n    } catch (e) {}\n\n    return false;\n  }\n  /**\r\n   * Add the start marker and call the function that inits the store search.\r\n   *\r\n   * @since\t1.1.0\r\n   * @param\t{object} startLatLng The start coordinates\r\n   * @param\t{object} infoWindow  The infoWindow object\r\n   * @returns {void}\r\n   */\n\n\n  function showStores(startLatLng, infoWindow) {\n    addMarker(startLatLng, 0, \"\", true, infoWindow); // This marker is the 'start location' marker. With a storeId of 0, no name and is draggable\n\n    findStoreLocations(startLatLng, resetMap, autoLoad, infoWindow);\n  }\n  /**\r\n   * Compare the current useragent to a list of known mobile useragents ( not optimal, I know ).\r\n   *\r\n   * @since\t1.2.20\r\n   * @returns {boolean} Whether the useragent is from a known mobile useragent or not.\r\n   */\n\n\n  function checkMobileUserAgent() {\n    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n  }\n  /**\r\n   * Check if Geolocation detection is supported.\r\n   *\r\n   * If there is an error / timeout with determining the users\r\n   * location, then we use the 'start point' value from the settings\r\n   * as the start location through the showStores function.\r\n   *\r\n   * @since\t1.0.0\r\n   * @param\t{object} startLatLng The start coordinates\r\n   * @param\t{object} infoWindow  The infoWindow object\r\n   * @returns {void}\r\n   */\n\n\n  function checkGeolocation(startLatLng, infoWindow) {\n    if (navigator.geolocation) {\n      var geolocationInProgress,\n          locationTimeout,\n          keepStartMarker = false,\n          timeout = Number(wpslSettings.geoLocationTimeout); // Make the direction icon flash every 600ms to indicate the geolocation attempt is in progress.\n\n      geolocationInProgress = setInterval(function () {\n        $(\".wpsl-icon-direction\").toggleClass(\"wpsl-active-icon\");\n      }, 600);\n      /*\r\n       * If the user doesn't approve the geolocation request within the value set in\r\n       * wpslSettings.geoLocationTimeout, then the default map is loaded.\r\n       *\r\n       * You can increase the timeout value with the wpsl_geolocation_timeout filter.\r\n       */\n\n      locationTimeout = setTimeout(function () {\n        geolocationFinished(geolocationInProgress);\n        showStores(startLatLng, infoWindow);\n      }, timeout);\n      navigator.geolocation.getCurrentPosition(function (position) {\n        geolocationFinished(geolocationInProgress);\n        clearTimeout(locationTimeout);\n        /*\r\n         * If the timeout is triggerd and the user later decides to enable\r\n         * the geolocation detection again, it gets messy with multiple start markers.\r\n         *\r\n         * So we first clear the map before adding new ones.\r\n         */\n\n        deleteOverlays(keepStartMarker);\n        handleGeolocationQuery(startLatLng, position, resetMap, infoWindow);\n        /*\r\n         * Workaround for this bug in Firefox https://bugzilla.mozilla.org/show_bug.cgi?id=1283563.\r\n         * to keep track if the geolocation code has already run.\r\n         *\r\n         * Otherwise after the users location is determined succesfully the code\r\n         * will also detect the returned error, and triggers showStores() to\r\n         * run with the start location set in the incorrect location.\r\n         */\n\n        $(\".wpsl-search\").addClass(\"wpsl-geolocation-run\");\n      }, function (error) {\n        /*\r\n         * Only show the geocode errors if the user actually clicked on the direction icon.\r\n         *\r\n         * Otherwise if the \"Attempt to auto-locate the user\" option is enabled on the settings page,\r\n         * and the geolocation attempt fails for whatever reason ( blocked in browser, unavailable etc ).\r\n         * Then the first thing the visitor will see on pageload is an alert box, which isn't very userfriendly.\r\n         *\r\n         * If an error occurs on pageload without the user clicking on the direction icon,\r\n         * the default map is shown without any alert boxes.\r\n         */\n        if ($(\".wpsl-icon-direction\").hasClass(\"wpsl-user-activated\") && !$(\".wpsl-search\").hasClass(\"wpsl-geolocation-run\")) {\n          switch (error.code) {\n            case error.PERMISSION_DENIED:\n              alert(wpslGeolocationErrors.denied);\n              break;\n\n            case error.POSITION_UNAVAILABLE:\n              alert(wpslGeolocationErrors.unavailable);\n              break;\n\n            case error.TIMEOUT:\n              alert(wpslGeolocationErrors.timeout);\n              break;\n\n            default:\n              alert(wpslGeolocationErrors.generalError);\n              break;\n          }\n\n          $(\".wpsl-icon-direction\").removeClass(\"wpsl-active-icon\");\n        } else if (!$(\".wpsl-search\").hasClass(\"wpsl-geolocation-run\")) {\n          clearTimeout(locationTimeout);\n          showStores(startLatLng, infoWindow);\n        }\n      }, {\n        maximumAge: 60000,\n        timeout: timeout,\n        enableHighAccuracy: true\n      });\n    } else {\n      alert(wpslGeolocationErrors.unavailable);\n      showStores(startLatLng, infoWindow);\n    }\n  }\n  /**\r\n   * Clean up after the geolocation attempt finished.\r\n   *\r\n   * @since\t2.0.0\r\n   * @param\t{number} geolocationInProgress\r\n   * @returns {void}\r\n   */\n\n\n  function geolocationFinished(geolocationInProgress) {\n    clearInterval(geolocationInProgress);\n    $(\".wpsl-icon-direction\").removeClass(\"wpsl-active-icon\");\n  }\n  /**\r\n   * Handle the data returned from the Geolocation API.\r\n   *\r\n   * If there is an error / timeout determining the users location,\r\n   * then we use the 'start point' value from the settings as the start location through the showStores function.\r\n   *\r\n   * @since\t1.0.0\r\n   * @param\t{object}  startLatLng The start coordinates\r\n   * @param\t{object}  position    The latlng coordinates from the geolocation attempt\r\n   * @param\t{boolean} resetMap    Whether we should reset the map or not\r\n   * @param\t{object}  infoWindow  The infoWindow object\r\n   * @returns {void}\r\n   */\n\n\n  function handleGeolocationQuery(startLatLng, position, resetMap, infoWindow) {\n    if (typeof position === \"undefined\") {\n      showStores(startLatLng, infoWindow);\n    } else {\n      var latLng = new google.maps.LatLng(position.coords.latitude, position.coords.longitude);\n      /*\r\n       * Store the latlng from the geolocation for when the user hits \"reset\" again\r\n       * without having to ask for permission again.\r\n       */\n\n      userGeolocation = {\n        position: position,\n        newRequest: true\n      };\n      map.setCenter(latLng);\n      addMarker(latLng, 0, \"\", true, infoWindow); // This marker is the 'start location' marker. With a storeId of 0, no name and is draggable\n\n      findStoreLocations(latLng, resetMap, autoLoad, infoWindow);\n    }\n  }\n  /**\r\n   * Handle clicks on the store locator search button.\r\n   *\r\n   * @since\t1.0.0\r\n   * @todo disable button while AJAX request still runs.\r\n   * @param\t{object} infoWindow The infoWindow object\r\n   * @returns {void}\r\n   */\n\n\n  function searchLocationBtn(infoWindow) {\n    $(\"#wpsl-search-btn\").unbind(\"click\").bind(\"click\", function (e) {\n      removeDangerBorder(\"#wpsl-radius-dropdown\");\n      removeDangerBorder(\"#wpsl-results-dropdown\");\n      $(\"#wpsl-search-input\").removeClass();\n\n      if (!$(\"#wpsl-search-input\").val()) {\n        $(\"#wpsl-search-input\").addClass(\"wpsl-error\").focus();\n      } else if (selectedEmptyInput()) {\n        alert(\"Please select a Search Radius and/or Results to display\");\n        addDangerBorder();\n      } else {\n        resetSearchResults();\n        /*\r\n         * Check if we need to geocode the user input,\r\n         * or if autocomplete is enabled and we already\r\n         * have the latlng values.\r\n         */\n\n        if (wpslSettings.autoComplete == 1 && typeof autoCompleteLatLng !== \"undefined\") {\n          prepareStoreSearch(autoCompleteLatLng, infoWindow);\n        } else {\n          codeAddress(infoWindow);\n        }\n      }\n\n      return false;\n    });\n  }\n  /**\r\n   * Force the open InfoBox info window to close\r\n   *\r\n   * This is required if the user makes a new search,\r\n   * or clicks on the \"Directions\" link.\r\n   *\r\n   * @since  2.0.0\r\n   * @return {void}\r\n   */\n\n\n  function closeInfoBoxWindow() {\n    if (typeof wpslSettings.infoWindowStyle !== \"undefined\" && wpslSettings.infoWindowStyle == \"infobox\" && typeof openInfoWindow[0] !== \"undefined\") {\n      openInfoWindow[0].close();\n    }\n  }\n  /**\r\n   * Add the 'reload' and 'find location' icon to the map.\r\n   *\r\n   * @since  2.0.0\r\n   * @param  {object} settings   Map settings\r\n   * @param  {object} map\t\t   The map object\r\n   * @param  {object} infoWindow The info window object\r\n   * @return {void}\r\n   */\n\n\n  function mapControlIcons(settings, map, infoWindow) {\n    // Once the map has finished loading include the map control button(s).\n    google.maps.event.addListenerOnce(map, \"tilesloaded\", function () {\n      // Add the html for the map controls to the map.\n      $(\".gm-style\").append(wpslSettings.mapControls);\n\n      if ($(\".wpsl-icon-reset, #wpsl-reset-map\").length > 0) {\n        // Bind the reset map button.\n        resetMapBtn(settings.startLatLng, infoWindow);\n        /*\r\n         * Hide it to prevent users from clicking it before\r\n         * the store location are placed on the map.\r\n         */\n\n        $(\".wpsl-icon-reset\").hide();\n      } // Bind the direction button to trigger a new geolocation request.\n\n\n      $(\".wpsl-icon-direction\").on(\"click\", function () {\n        $(this).addClass(\"wpsl-user-activated\");\n        checkGeolocation(settings.startLatLng, infoWindow);\n      });\n    });\n  }\n  /**\r\n   * Handle clicks on the \"Reset\" button.\r\n   *\r\n   * @since\t1.0.0\r\n   * @param\t{object} startLatLng The start coordinates\r\n   * @param\t{object} infoWindow  The infoWindow object\r\n   * @returns {void}\r\n   */\n\n\n  function resetMapBtn(startLatLng, infoWindow) {\n    $(\".wpsl-icon-reset, #wpsl-reset-map\").on(\"click\", function () {\n      var keepStartMarker = false,\n          resetMap = true;\n      /*\r\n       * Check if a map reset is already in progress,\r\n       * if so prevent another one from starting.\r\n       */\n\n      if ($(this).hasClass(\"wpsl-in-progress\")) {\n        return;\n      }\n      /*\r\n       * When the start marker is dragged the autoload value is set to false.\r\n       * So we need to check the correct value when the reset button is\r\n       * pushed before reloading the stores.\r\n       */\n\n\n      if (wpslSettings.autoLoad == 1) {\n        autoLoad = 1;\n      } // Check if the latlng or zoom has changed since pageload, if so there is something to reset.\n\n\n      if (map.getCenter().lat() !== mapDefaults.centerLatlng.lat() || map.getCenter().lng() !== mapDefaults.centerLatlng.lng() || map.getZoom() !== mapDefaults.zoomLevel) {\n        deleteOverlays(keepStartMarker);\n        $(\"#wpsl-search-input\").val(\"\").removeClass(); // We use this to prevent multiple reset request.\n\n        $(\".wpsl-icon-reset\").addClass(\"wpsl-in-progress\"); // If marker clusters exist, remove them from the map.\n\n        if (markerClusterer) {\n          markerClusterer.clearMarkers();\n        } // Remove the start marker.\n\n\n        deleteStartMarker(); // Reset the dropdown values.\n\n        resetDropdowns();\n\n        if (wpslSettings.autoLocate == 1) {\n          handleGeolocationQuery(startLatLng, userGeolocation.position, resetMap, infoWindow);\n        } else {\n          showStores(startLatLng, infoWindow);\n        }\n      } // Make sure the stores are shown and the direction details are hidden.\n\n\n      $(\"#wpsl-stores\").show();\n      $(\"#wpsl-direction-details\").hide();\n    });\n  }\n  /**\r\n   * Remove the start marker from the map.\r\n   *\r\n   * @since   1.2.12\r\n   * @returns {void}\r\n   */\n\n\n  function deleteStartMarker() {\n    if (typeof startMarkerData !== \"undefined\" && startMarkerData !== \"\") {\n      startMarkerData.setMap(null);\n      startMarkerData = \"\";\n    }\n  }\n  /**\r\n   * Reset the dropdown values for the max results,\r\n   * and search radius after the \"reset\" button is triggerd.\r\n   *\r\n   * @since   1.1.0\r\n   * @returns {void}\r\n   */\n\n\n  function resetDropdowns() {\n    console.log(\"THis was triggered\");\n    var i,\n        arrayLength,\n        dataValue,\n        catText,\n        $customDiv,\n        $customFirstLi,\n        customSelectedText,\n        customSelectedData,\n        defaultFilters = $(\"#wpsl-wrap\").hasClass(\"wpsl-default-filters\"),\n        defaultValues = [wpslSettings.searchRadius + \" \" + wpslSettings.distanceUnit, wpslSettings.maxResults],\n        dropdowns = [\"wpsl-radius\", \"wpsl-results\"];\n\n    for (i = 0, arrayLength = dropdowns.length; i < arrayLength; i++) {\n      $(\"#\" + dropdowns[i] + \" select\").val(parseInt(defaultValues[i]));\n      $(\"#\" + dropdowns[i] + \" li\").removeClass();\n\n      if (dropdowns[i] == \"wpsl-radius\") {\n        dataValue = wpslSettings.searchRadius;\n      } else if (dropdowns[i] == \"wpsl-results\") {\n        dataValue = wpslSettings.maxResults;\n      }\n\n      $(\"#\" + dropdowns[i] + \" li\").each(function () {\n        if ($(this).text() === defaultValues[i]) {\n          $(this).addClass(\"wpsl-selected-dropdown\");\n          $(\"#\" + dropdowns[i] + \" .wpsl-selected-item\").html(defaultValues[i]).attr(\"data-value\", dataValue);\n        }\n      });\n    }\n    /**\r\n     * Reset the category dropdown.\r\n     * @todo look for other way to do this in combination with above code. Maybe allow users to define a default cat on the settings page?\r\n     */\n\n\n    if ($(\"#wpsl-category\").length) {\n      $(\"#wpsl-category select\").val(0);\n      $(\"#wpsl-category li\").removeClass();\n      $(\"#wpsl-category li:first-child\").addClass(\"wpsl-selected-dropdown\");\n      catText = $(\"#wpsl-category li:first-child\").text();\n      $(\"#wpsl-category .wpsl-selected-item\").html(catText).attr(\"data-value\", 0);\n    } // If any custom dropdowns exist, then we reset them as well.\n\n\n    if ($(\".wpsl-custom-dropdown\").length > 0) {\n      $(\".wpsl-custom-dropdown\").each(function (index) {\n        // Check if we are dealing with the styled dropdowns, or the default select dropdowns.\n        if (!defaultFilters) {\n          $customDiv = $(this).siblings(\"div\");\n          $customFirstLi = $customDiv.find(\"li:first-child\");\n          customSelectedText = $customFirstLi.text();\n          customSelectedData = $customFirstLi.attr(\"data-value\");\n          $customDiv.find(\"li\").removeClass();\n          $customDiv.prev().html(customSelectedText).attr(\"data-value\", customSelectedData);\n        } else {\n          $(this).find(\"option\").removeAttr(\"selected\");\n        }\n      });\n    }\n  } // Handle the click on the back button when the route directions are displayed.\n\n\n  $(\"#wpsl-result-list\").on(\"click\", \".wpsl-back\", function () {\n    var i, len; // Remove the directions from the map.\n\n    directionsDisplay.setMap(null); // Restore the store markers on the map.\n\n    for (i = 0, len = markersArray.length; i < len; i++) {\n      markersArray[i].setMap(map);\n    } // Restore the start marker on the map.\n\n\n    if (typeof startMarkerData !== \"undefined\" && startMarkerData !== \"\") {\n      startMarkerData.setMap(map);\n    } // If marker clusters are enabled, restore them.\n\n\n    if (markerClusterer) {\n      checkMarkerClusters();\n    }\n\n    map.setCenter(directionMarkerPosition.centerLatlng);\n    map.setZoom(directionMarkerPosition.zoomLevel);\n    $(\".wpsl-direction-before, .wpsl-direction-after\").remove();\n    $(\"#wpsl-stores\").show();\n    $(\"#wpsl-direction-details\").hide();\n    return false;\n  });\n  /**\r\n   * Show the driving directions.\r\n   *\r\n   * @since\t1.1.0\r\n   * @param\t{object} e The clicked elemennt\r\n   * @returns {void}\r\n   */\n\n  function renderDirections(e) {\n    var i, start, end, len, storeId; // Force the open InfoBox info window to close.\n\n    closeInfoBoxWindow();\n    /*\r\n     * The storeId is placed on the li in the results list,\r\n     * but in the marker it will be on the wrapper div. So we check which one we need to target.\r\n     */\n\n    if (e.parents(\"li\").length > 0) {\n      storeId = e.parents(\"li\").data(\"store-id\");\n    } else {\n      storeId = e.parents(\".wpsl-info-window\").data(\"store-id\");\n    } // Check if we need to get the start point from a dragged marker.\n\n\n    if (typeof startMarkerData !== \"undefined\" && startMarkerData !== \"\") {\n      start = startMarkerData.getPosition();\n    } // Used to restore the map back to the state it was in before the user clicked on 'directions'.\n\n\n    directionMarkerPosition = {\n      centerLatlng: map.getCenter(),\n      zoomLevel: map.getZoom()\n    }; // Find the latlng that belongs to the start and end point.\n\n    for (i = 0, len = markersArray.length; i < len; i++) {\n      // Only continue if the start data is still empty or undefined.\n      if (markersArray[i].storeId == 0 && (typeof start === \"undefined\" || start === \"\")) {\n        start = markersArray[i].getPosition();\n      } else if (markersArray[i].storeId == storeId) {\n        end = markersArray[i].getPosition();\n      }\n    }\n\n    if (start && end) {\n      $(\"#wpsl-direction-details ul\").empty();\n      $(\".wpsl-direction-before, .wpsl-direction-after\").remove();\n      calcRoute(start, end);\n    } else {\n      alert(wpslLabels.generalError);\n    }\n  }\n  /**\r\n   * Check what effect is triggerd once a user hovers over the store list.\r\n   * Either bounce the corresponding marker up and down, open the info window or ignore it.\r\n   */\n\n\n  if ($(\"#wpsl-gmap\").length) {\n    if (wpslSettings.markerEffect == \"bounce\") {\n      $(\"#wpsl-stores\").on(\"mouseenter\", \"li\", function () {\n        letsBounce($(this).data(\"store-id\"), \"start\");\n      });\n      $(\"#wpsl-stores\").on(\"mouseleave\", \"li\", function () {\n        letsBounce($(this).data(\"store-id\"), \"stop\");\n      });\n    } else if (wpslSettings.markerEffect == \"info_window\") {\n      $(\"#wpsl-stores\").on(\"mouseenter\", \"li\", function () {\n        var i, len;\n\n        for (i = 0, len = markersArray.length; i < len; i++) {\n          if (markersArray[i].storeId == $(this).data(\"store-id\")) {\n            google.maps.event.trigger(markersArray[i], \"click\");\n            map.setCenter(markersArray[i].position);\n          }\n        }\n      });\n    }\n  }\n  /**\r\n   * Let a single marker bounce.\r\n   *\r\n   * @since\t1.0.0\r\n   * @param\t{number} storeId The storeId of the marker that we need to bounce on the map\r\n   * @param\t{string} status  Indicates whether we should stop or start the bouncing\r\n   * @returns {void}\r\n   */\n\n\n  function letsBounce(storeId, status) {\n    var i, len, marker; // Find the correct marker to bounce based on the storeId.\n\n    for (i = 0, len = markersArray.length; i < len; i++) {\n      if (markersArray[i].storeId == storeId) {\n        marker = markersArray[i];\n\n        if (status == \"start\") {\n          marker.setAnimation(google.maps.Animation.BOUNCE);\n        } else {\n          marker.setAnimation(null);\n        }\n      }\n    }\n  }\n  /**\r\n   * Calculate the route from the start to the end.\r\n   *\r\n   * @since\t1.0.0\r\n   * @param\t{object} start The latlng from the start point\r\n   * @param\t{object} end   The latlng from the end point\r\n   * @returns {void}\r\n   */\n\n\n  function calcRoute(start, end) {\n    var legs,\n        len,\n        step,\n        index,\n        direction,\n        i,\n        j,\n        distanceUnit,\n        directionOffset,\n        request,\n        directionStops = \"\";\n\n    if (wpslSettings.distanceUnit == \"km\") {\n      distanceUnit = \"METRIC\";\n    } else {\n      distanceUnit = \"IMPERIAL\";\n    }\n\n    request = {\n      origin: start,\n      destination: end,\n      travelMode: wpslSettings.directionsTravelMode,\n      unitSystem: google.maps.UnitSystem[distanceUnit]\n    };\n    directionsService.route(request, function (response, status) {\n      if (status == google.maps.DirectionsStatus.OK) {\n        directionsDisplay.setMap(map);\n        directionsDisplay.setDirections(response);\n\n        if (response.routes.length > 0) {\n          direction = response.routes[0]; // Loop over the legs and steps of the directions.\n\n          for (i = 0; i < direction.legs.length; i++) {\n            legs = direction.legs[i];\n\n            for (j = 0, len = legs.steps.length; j < len; j++) {\n              step = legs.steps[j];\n              index = j + 1;\n              directionStops = directionStops + \"<li><div class='wpsl-direction-index'>\" + index + \"</div><div class='wpsl-direction-txt'>\" + step.instructions + \"</div><div class='wpsl-direction-distance'>\" + step.distance.text + \"</div></li>\";\n            }\n          }\n\n          $(\"#wpsl-direction-details ul\").append(directionStops).before(\"<div class='wpsl-direction-before'><a class='wpsl-back' id='wpsl-direction-start' href='#'>\" + wpslLabels.back + \"</a><div><span class='wpsl-total-distance'>\" + direction.legs[0].distance.text + \"</span> - <span class='wpsl-total-durations'>\" + direction.legs[0].duration.text + \"</span></div></div>\").after(\"<p class='wpsl-direction-after'>\" + response.routes[0].copyrights + \"</p>\");\n          $(\"#wpsl-direction-details\").show(); // Remove all single markers from the map.\n\n          for (i = 0, len = markersArray.length; i < len; i++) {\n            markersArray[i].setMap(null);\n          } // Remove the marker clusters from the map.\n\n\n          if (markerClusterer) {\n            markerClusterer.clearMarkers();\n          } // Remove the start marker from the map.\n\n\n          if (typeof startMarkerData !== \"undefined\" && startMarkerData !== \"\") {\n            startMarkerData.setMap(null);\n          }\n\n          $(\"#wpsl-stores\").hide(); // Make sure the start of the route directions are visible if the store listings are shown below the map.\n\n          if (wpslSettings.templateId == 1) {\n            directionOffset = $(\"#wpsl-gmap\").offset();\n            $(window).scrollTop(directionOffset.top);\n          }\n        }\n      } else {\n        directionErrors(status);\n      }\n    });\n  }\n  /**\r\n   * Geocode the user input.\r\n   *\r\n   * @since\t1.0.0\r\n   * @param\t{object} infoWindow The infoWindow object\r\n   * @returns {void}\r\n   */\n\n\n  function codeAddress(infoWindow) {\n    var latLng,\n        request = {}; // Check if we need to set the geocode component restrictions.\n\n    if (typeof wpslSettings.geocodeComponents !== \"undefined\" && !$.isEmptyObject(wpslSettings.geocodeComponents)) {\n      request.componentRestrictions = wpslSettings.geocodeComponents;\n\n      if (typeof request.componentRestrictions.postalCode !== \"undefined\") {\n        request.componentRestrictions.postalCode = $(\"#wpsl-search-input\").val();\n      } else {\n        request.address = $(\"#wpsl-search-input\").val();\n      }\n    } else {\n      request.address = $(\"#wpsl-search-input\").val();\n    }\n\n    geocoder.geocode(request, function (response, status) {\n      if (status == google.maps.GeocoderStatus.OK) {\n        if (statistics.enabled) {\n          collectStatsData(response);\n        }\n\n        latLng = response[0].geometry.location;\n        prepareStoreSearch(latLng, infoWindow);\n      } else {\n        geocodeErrors(status);\n      }\n    });\n  }\n  /**\r\n   * Prepare a new location search.\r\n   *\r\n   * @since\t2.2.0\r\n   * @param\t{object} latLng \tThe coordinates\r\n   * @param\t{object} infoWindow The infoWindow object.\r\n   * @returns {void}\r\n   */\n\n\n  function prepareStoreSearch(latLng, infoWindow) {\n    var autoLoad = false; // Add a new start marker.\n\n    addMarker(latLng, 0, \"\", true, infoWindow); // Try to find stores that match the radius, location criteria.\n\n    findStoreLocations(latLng, resetMap, autoLoad, infoWindow);\n  }\n  /**\r\n   * Reverse geocode the passed coordinates and set the returned zipcode in the input field.\r\n   *\r\n   * @since\t1.0.0\r\n   * @param\t{object} latLng The coordinates of the location that should be reverse geocoded\r\n   * @returns {object} response The address components if the stats add-on is active.\r\n   */\n\n\n  function reverseGeocode(latLng, callback) {\n    var userLocation,\n        lat = latLng.lat().toFixed(5),\n        lng = latLng.lng().toFixed(5);\n\n    latLng.lat = function () {\n      return parseFloat(lat);\n    };\n\n    latLng.lng = function () {\n      return parseFloat(lng);\n    };\n\n    geocoder.geocode({\n      latLng: latLng\n    }, function (response, status) {\n      if (status == google.maps.GeocoderStatus.OK) {\n        if (wpslSettings.autoLocate == 1 && userGeolocation.newRequest) {\n          userLocation = filterApiResponse(response);\n\n          if (userLocation !== \"\") {\n            $(\"#wpsl-search-input\").val(userLocation);\n          }\n          /*\r\n           * Prevent the zip from being placed in the input field\r\n           * again after the users location is determined.\r\n           */\n\n\n          userGeolocation.newRequest = false;\n        }\n\n        if (wpslSettings.directionRedirect) {\n          startAddress = response[0].formatted_address;\n        } // Prevent it from running on autoload when the input field is empty.\n\n\n        if (statistics.enabled && $(\"#wpsl-search-input\").val().length > 0) {\n          if ($.isEmptyObject(statistics.addressComponents)) {\n            collectStatsData(response);\n          }\n        }\n\n        callback();\n      } else {\n        geocodeErrors(status);\n      }\n    });\n  }\n  /**\r\n   * Collect the data for the statistics\r\n   * add-on from the Google Geocode API.\r\n   *\r\n   * @since 2.2.18\r\n   * @param response\r\n   * @returns {void}\r\n   */\n\n\n  function collectStatsData(response) {\n    var requiredFields,\n        addressLength,\n        responseType,\n        countryCode,\n        responseLength,\n        missingFields = {},\n        statsData = {};\n    countryCode = findCountryCode(response);\n    /**\r\n     * The UK is a special case how the city / town / region / country data\r\n     * is structured in the Geocode API response. So we adjust the structure a bit.\r\n     *\r\n     * We later check which field contained the city / town data\r\n     * and if necessary later move it to the correct one.\r\n     */\n\n    if (countryCode == \"GB\") {\n      requiredFields = {\n        city: \"postal_town\",\n        city_locality: \"locality,political\",\n        region: \"administrative_area_level_2,political\",\n        country: \"administrative_area_level_1,political\"\n      };\n    } else {\n      requiredFields = {\n        city: \"locality,political\",\n        region: \"administrative_area_level_1,political\",\n        country: \"country,political\"\n      };\n    }\n\n    addressLength = response[0].address_components.length; // Loop over the first row in the API response.\n\n    for (i = 0; i < addressLength; i++) {\n      responseType = response[0].address_components[i].types;\n\n      for (var key in requiredFields) {\n        if (requiredFields[key] == responseType.join(\",\")) {\n          // In rare cases the long name is empty.\n          if (response[0].address_components[i].long_name.length > 0) {\n            statsData[key] = response[0].address_components[i].long_name;\n          } else {\n            statsData[key] = response[0].address_components[i].short_name;\n          }\n        }\n      }\n    }\n    /**\r\n     * Check if we have the required fields. This is often the case after\r\n     * grabbing the data from the first row, but in some cases we have to loop\r\n     * through all the data to get all the required data.\r\n     */\n\n\n    for (var key in requiredFields) {\n      if (typeof statsData[key] === \"undefined\") {\n        missingFields[key] = requiredFields[key];\n      }\n    }\n    /**\r\n     * In the UK the data we want is most of the time in the\r\n     * postal_town ( city ) field, which is often set on the first row.\r\n     *\r\n     * If this field contains data then don't continue and ignore\r\n     * the missing data in the locality field, which is more of a\r\n     * backup in case the 'postal_town' is missing in the API response.\r\n     */\n\n\n    if (countryCode == \"GB\") {\n      if (typeof missingFields.city_locality !== \"undefined\" && typeof missingFields.city === \"undefined\") {\n        missingFields = {};\n      }\n    }\n    /**\r\n     * If one or more required fields are missing,\r\n     * then loop through the remaining API data.\r\n     */\n\n\n    if (Object.keys(missingFields).length > 0) {\n      responseLength = response.length;\n      /**\r\n       * Loop over the remaining API results,\r\n       * but skip the first row since we already checked that one.\r\n       */\n\n      for (i = 1; i < responseLength; i++) {\n        addressLength = response[i].address_components.length;\n\n        for (j = 0; j < addressLength; j++) {\n          responseType = response[i].address_components[j].types;\n\n          for (var key in missingFields) {\n            if (requiredFields[key] == responseType.join(\",\")) {\n              statsData[key] = response[i].address_components[j].long_name;\n            }\n          }\n        }\n      }\n    }\n    /**\r\n     * In rare cases, and as far I know this only happens in the UK, the city / town name\r\n     * is often set in the 'postal_town' ( city ) field in the Google API response.\r\n     *\r\n     * But in some cases the 'locality,political' ( city_locality ) field is also\r\n     * set in the first row ( where it's located for locations in the rest of the world ).\r\n     *\r\n     * When both fields are set the 'locality,political' ( city_locality ) will contain more\r\n     * accurate details, so we copy it's value back to the city field.\r\n     */\n\n\n    if (typeof statsData.city_locality !== \"undefined\" && statsData.city_locality.length > 0) {\n      statsData.city = statsData.city_locality;\n      delete statsData.city_locality;\n    }\n\n    statistics.addressComponents = statsData;\n  }\n  /**\r\n   * Grab the country name from the API response.\r\n   *\r\n   * @since 2.2.18\r\n   * @param {object}  response \t The API response\r\n   * @return {string} countryCode The country code found in the API response.\r\n   */\n\n\n  function findCountryCode(response) {\n    var responseType,\n        countryCode = \"\";\n    $.each(response[0].address_components, function (index) {\n      responseType = response[0].address_components[index].types;\n\n      if (responseType.join(\",\") == \"country,political\") {\n        countryCode = response[0].address_components[index].short_name;\n        return false;\n      }\n    });\n    return countryCode;\n  }\n  /**\r\n   * Filter out the zip / city name from the API response\r\n   *\r\n   * @since\t1.0.0\r\n   * @param\t{object} response \t   The complete Google API response\r\n   * @returns {string} userLocation Either the users zip / city name the user is located in\r\n   */\n\n\n  function filterApiResponse(response) {\n    var i,\n        j,\n        responseType,\n        addressLength,\n        userLocation,\n        filteredData = {},\n        responseLength = response.length;\n\n    for (i = 0; i < responseLength; i++) {\n      addressLength = response[i].address_components.length;\n\n      for (j = 0; j < addressLength; j++) {\n        responseType = response[i].address_components[j].types;\n\n        if (/^postal_code$/.test(responseType) || /^postal_code,postal_code_prefix$/.test(responseType)) {\n          filteredData.zip = response[i].address_components[j].long_name;\n          break;\n        }\n\n        if (/^locality,political$/.test(responseType)) {\n          filteredData.locality = response[i].address_components[j].long_name;\n        }\n      }\n\n      if (typeof filteredData.zip !== \"undefined\") {\n        break;\n      }\n    } // If no zip code was found ( it's rare, but it happens ), then we use the city / town name as backup.\n\n\n    if (typeof filteredData.zip === \"undefined\" && typeof filteredData.locality !== \"undefined\") {\n      userLocation = filteredData.locality;\n    } else {\n      userLocation = filteredData.zip;\n    }\n\n    return userLocation;\n  }\n  /**\r\n   * Call the function to make the ajax request to load the store locations.\r\n   *\r\n   * If we need to show the driving directions on maps.google.com itself,\r\n   * we first need to geocode the start latlng into a formatted address.\r\n   *\r\n   * @since\t1.0.0\r\n   * @param\t{object}  startLatLng The coordinates\r\n   * @param\t{boolean} resetMap    Whether we should reset the map or not\r\n   * @param\t{string}  autoLoad    Check if we need to autoload all the stores\r\n   * @param\t{object}  infoWindow  The infoWindow object\r\n   * @returns {void}\r\n   */\n\n\n  function findStoreLocations(startLatLng, resetMap, autoLoad, infoWindow) {\n    if (wpslSettings.directionRedirect == 1 || statistics.enabled) {\n      reverseGeocode(startLatLng, function () {\n        makeAjaxRequest(startLatLng, resetMap, autoLoad, infoWindow);\n      });\n    } else {\n      makeAjaxRequest(startLatLng, resetMap, autoLoad, infoWindow);\n    }\n  }\n  /**\r\n   * Make the AJAX request to load the store data.\r\n   *\r\n   * @since\t1.2.0\r\n   * @param\t{object}  startLatLng The latlng used as the starting point\r\n   * @param\t{boolean} resetMap    Whether we should reset the map or not\r\n   * @param\t{string}  autoLoad    Check if we need to autoload all the stores\r\n   * @param\t{object}  infoWindow  The infoWindow object\r\n   * @returns {void}\r\n   */\n\n\n  function makeAjaxRequest(startLatLng, resetMap, autoLoad, infoWindow) {\n    var latLng,\n        noResultsMsg,\n        ajaxData,\n        storeData = \"\",\n        draggable = false,\n        template = $(\"#wpsl-listing-template\").html(),\n        $storeList = $(\"#wpsl-stores ul\"),\n        preloader = wpslSettings.url + \"img/ajax-loader.gif\";\n    ajaxData = collectAjaxData(startLatLng, resetMap, autoLoad); // Add the preloader.\n\n    $storeList.empty().append(\"<li class='wpsl-preloader'><img src='\" + preloader + \"'/>\" + wpslLabels.preloader + \"</li>\");\n    $(\"#wpsl-wrap\").removeClass(\"wpsl-no-results\");\n    $.get(wpslSettings.ajaxurl, ajaxData, function (response) {\n      // Remove the preloaders and no results msg.\n      $(\".wpsl-preloader\").remove();\n\n      if (response.length > 0 && typeof response.addon == \"undefined\") {\n        // Loop over the returned locations.\n        $.each(response, function (index) {\n          _.extend(response[index], templateHelpers); // Add the location maker to the map.\n\n\n          latLng = new google.maps.LatLng(response[index].lat, response[index].lng);\n          addMarker(latLng, response[index].id, response[index], draggable, infoWindow); // Create the HTML output with help from underscore js.\n\n          storeData = storeData + _.template(template)(response[index]);\n        });\n        $(\"#wpsl-result-list\").off(\"click\", \".wpsl-directions\"); // Remove the old search results.\n\n        $storeList.empty(); // Add the html for the store listing to the <ul>.\n\n        $storeList.append(storeData);\n        $(\"#wpsl-result-list\").on(\"click\", \".wpsl-directions\", function () {\n          // Check if we need to render the direction on the map.\n          if (wpslSettings.directionRedirect != 1) {\n            renderDirections($(this));\n            return false;\n          }\n        }); // Do we need to create a marker cluster?\n\n        checkMarkerClusters();\n        $(\"#wpsl-result-list p:empty\").remove();\n      } else {\n        addMarker(startLatLng, 0, \"\", true, infoWindow);\n        noResultsMsg = getNoResultsMsg();\n        $(\"#wpsl-wrap\").addClass(\"wpsl-no-results\");\n        $storeList.html(\"<li class='wpsl-no-results-msg'>\" + noResultsMsg + \"</li>\");\n      }\n      /*\r\n       * Do we need to adjust the zoom level so that all the markers fit in the viewport,\r\n       * or just center the map on the start marker.\r\n       */\n\n\n      if (wpslSettings.runFitBounds == 1) {\n        fitBounds();\n      } else {\n        map.setZoom(Number(wpslSettings.zoomLevel));\n        map.setCenter(markersArray[0].position);\n      }\n      /*\r\n       * Store the default zoom and latlng values the first time\r\n       * all the stores are added to the map.\r\n       *\r\n       * This way when a user clicks the reset button we can check if the\r\n       * zoom/latlng values have changed, and if they have, then we know we\r\n       * need to reload the map.\r\n       */\n\n\n      if (wpslSettings.resetMap == 1) {\n        if ($.isEmptyObject(mapDefaults)) {\n          google.maps.event.addListenerOnce(map, \"tilesloaded\", function () {\n            mapDefaults = {\n              centerLatlng: map.getCenter(),\n              zoomLevel: map.getZoom()\n            };\n            /*\r\n             * Because the reset icon exists, we need to adjust\r\n             * the styling of the direction icon.\r\n             */\n\n            $(\"#wpsl-map-controls\").addClass(\"wpsl-reset-exists\");\n            /*\r\n             * The reset initialy is set to hidden to prevent\r\n             * users from clicking it before the map is loaded.\r\n             */\n\n            $(\".wpsl-icon-reset, #wpsl-reset-map\").show();\n          });\n        }\n\n        $(\".wpsl-icon-reset\").removeClass(\"wpsl-in-progress\");\n      }\n    }); // Move the mousecursor to the store search field if the focus option is enabled.\n\n    if (wpslSettings.mouseFocus == 1 && !checkMobileUserAgent()) {\n      $(\"#wpsl-search-input\").focus();\n    }\n  }\n  /**\r\n   * Collect the data we need to include in the AJAX request.\r\n   *\r\n   * @since\t2.2.0\r\n   * @param\t{object}  startLatLng The latlng used as the starting point\r\n   * @param\t{boolean} resetMap    Whether we should reset the map or not\r\n   * @param\t{string}  autoLoad    Check if we need to autoload all the stores\r\n   * @returns {object}  ajaxData\t  The collected data.\r\n   */\n\n\n  function collectAjaxData(startLatLng, resetMap, autoLoad) {\n    var maxResult,\n        radius,\n        customDropdownName,\n        customDropdownValue,\n        customCheckboxName,\n        categoryId = \"\",\n        isMobile = $(\"#wpsl-wrap\").hasClass(\"wpsl-mobile\"),\n        defaultFilters = $(\"#wpsl-wrap\").hasClass(\"wpsl-default-filters\"),\n        ajaxData = {\n      action: \"store_search\",\n      lat: startLatLng.lat(),\n      lng: startLatLng.lng()\n    };\n    /*\r\n     * If we reset the map we use the default dropdown values instead of the selected values.\r\n     * Otherwise we first make sure the filter val is valid before including the radius / max_results param\r\n     */\n\n    if (resetMap) {\n      ajaxData.max_results = wpslSettings.maxResults;\n      ajaxData.search_radius = wpslSettings.searchRadius;\n    } else {\n      if (isMobile || defaultFilters) {\n        maxResult = parseInt($(\"#wpsl-results .wpsl-dropdown\").val());\n        radius = parseInt($(\"#wpsl-radius .wpsl-dropdown\").val());\n      } else {\n        maxResult = parseInt($(\"#wpsl-results .wpsl-selected-item\").attr(\"data-value\"));\n        radius = parseInt($(\"#wpsl-radius .wpsl-selected-item\").attr(\"data-value\"));\n      } // If the max results or radius filter values are NaN, then we use the default value.\n\n\n      if (isNaN(maxResult)) {\n        ajaxData.max_results = wpslSettings.maxResults;\n      } else {\n        ajaxData.max_results = maxResult;\n      }\n\n      if (isNaN(radius)) {\n        ajaxData.search_radius = wpslSettings.searchRadius;\n      } else {\n        ajaxData.search_radius = radius;\n      }\n      /*\r\n       * If category ids are set through the wpsl shortcode, then we always need to include them.\r\n       * Otherwise check if the category dropdown exist, or if the checkboxes are used.\r\n       */\n\n\n      if (typeof wpslSettings.categoryIds !== \"undefined\") {\n        ajaxData.filter = wpslSettings.categoryIds;\n      } else if ($(\"#wpsl-category\").length > 0) {\n        if (isMobile || defaultFilters) {\n          categoryId = parseInt($(\"#wpsl-category .wpsl-dropdown\").val());\n        } else {\n          categoryId = parseInt($(\"#wpsl-category .wpsl-selected-item\").attr(\"data-value\"));\n        }\n\n        if (!isNaN(categoryId) && categoryId !== 0) {\n          ajaxData.filter = categoryId;\n        }\n      } else if ($(\"#wpsl-checkbox-filter\").length > 0) {\n        if ($(\"#wpsl-checkbox-filter input:checked\").length > 0) {\n          ajaxData.filter = getCheckboxIds();\n        }\n      } // Include values from custom dropdowns.\n\n\n      if ($(\".wpsl-custom-dropdown\").length > 0) {\n        $(\".wpsl-custom-dropdown\").each(function (index) {\n          customDropdownName = \"\";\n          customDropdownValue = \"\";\n\n          if (isMobile || defaultFilters) {\n            customDropdownName = $(this).attr(\"name\");\n            customDropdownValue = $(this).val();\n          } else {\n            customDropdownName = $(this).attr(\"name\");\n            customDropdownValue = $(this).next(\".wpsl-selected-item\").attr(\"data-value\");\n          }\n\n          if (customDropdownName && customDropdownValue) {\n            ajaxData[customDropdownName] = customDropdownValue;\n          }\n        });\n      } // Include values from custom checkboxes\n\n\n      if ($(\".wpsl-custom-checkboxes\").length > 0) {\n        $(\".wpsl-custom-checkboxes\").each(function (index) {\n          customCheckboxName = $(this).attr(\"data-name\");\n\n          if (customCheckboxName) {\n            ajaxData[customCheckboxName] = getCustomCheckboxValue(customCheckboxName);\n          }\n        });\n      }\n    }\n    /*\r\n     * If the autoload option is enabled, then we need to check if the included latlng\r\n     * is based on a geolocation attempt before including the autoload param.\r\n     *\r\n     * Because if both the geolocation and autoload options are enabled,\r\n     * and the geolocation attempt was successful, then we need to to include\r\n     * the skip_cache param.\r\n     *\r\n     * This makes sure the results don't come from an older transient based on the\r\n     * start location from the settings page, instead of the users actual location.\r\n     */\n\n\n    if (autoLoad == 1) {\n      if (typeof userGeolocation.position !== \"undefined\") {\n        ajaxData.skip_cache = 1;\n      } else {\n        ajaxData.autoload = 1;\n        /*\r\n         * If the user set the 'category' attr on the wpsl shortcode, then include the cat ids\r\n         * to make sure only locations from the set categories are loaded on autoload.\r\n         */\n\n        if (typeof wpslSettings.categoryIds !== \"undefined\") {\n          ajaxData.filter = wpslSettings.categoryIds;\n        }\n      }\n    } // If the collection of statistics is enabled, then we include the searched value.\n\n\n    if (statistics.enabled && autoLoad == 0) {\n      ajaxData.search = $(\"#wpsl-search-input\").val();\n      ajaxData.statistics = statistics.addressComponents;\n    }\n\n    return ajaxData;\n  }\n  /**\r\n   * Get custom checkbox values by data-name group.\r\n   *\r\n   * If multiple selection are made, then the returned\r\n   * values are comma separated\r\n   *\r\n   * @since  2.2.8\r\n   * @param  {string} customCheckboxName The data-name value of the custom checkbox\r\n   * @return {string} customValue\t\t   The collected checkbox values separated by a comma\r\n   */\n\n\n  function getCustomCheckboxValue(customCheckboxName) {\n    var dataName = $(\"[data-name=\" + customCheckboxName + \"]\"),\n        customValue = [];\n    $(dataName).find(\"input:checked\").each(function (index) {\n      customValue.push($(this).val());\n    });\n    return customValue.join();\n  }\n  /**\r\n   * Check which no results msg we need to show.\r\n   *\r\n   * Either the default txt or a longer custom msg.\r\n   *\r\n   * @since  2.2.0\r\n   * @return string noResults The no results msg to show.\r\n   */\n\n\n  function getNoResultsMsg() {\n    var noResults;\n\n    if (typeof wpslSettings.noResults !== \"undefined\" && wpslSettings.noResults !== \"\") {\n      noResults = wpslSettings.noResults;\n    } else {\n      noResults = wpslLabels.noResults;\n    }\n\n    return noResults;\n  }\n  /**\r\n   * Collect the ids of the checked checkboxes.\r\n   *\r\n   * @since  2.2.0\r\n   * @return string catIds The cat ids from the checkboxes.\r\n   */\n\n\n  function getCheckboxIds() {\n    var catIds = $(\"#wpsl-checkbox-filter input:checked\").map(function () {\n      return $(this).val();\n    });\n    catIds = catIds.get();\n    catIds = catIds.join(\",\");\n    return catIds;\n  }\n  /**\r\n   * Check if cluster markers are enabled.\r\n   * If so, init the marker clustering with the\r\n   * correct gridsize and max zoom.\r\n   *\r\n   * @since  1.2.20\r\n   * @return {void}\r\n   */\n\n\n  function checkMarkerClusters() {\n    if (wpslSettings.markerClusters == 1) {\n      var markers,\n          markersArrayNoStart,\n          clusterZoom = Number(wpslSettings.clusterZoom),\n          clusterSize = Number(wpslSettings.clusterSize);\n\n      if (isNaN(clusterZoom)) {\n        clusterZoom = \"\";\n      }\n\n      if (isNaN(clusterSize)) {\n        clusterSize = \"\";\n      }\n      /*\r\n       * Remove the start location marker from the cluster so the location\r\n       * count represents the actual returned locations, and not +1 for the start location.\r\n       */\n\n\n      if (typeof wpslSettings.excludeStartFromCluster !== \"undefined\" && wpslSettings.excludeStartFromCluster == 1) {\n        markersArrayNoStart = markersArray.slice(0);\n        markersArrayNoStart.splice(0, 1);\n      }\n\n      markers = typeof markersArrayNoStart === \"undefined\" ? markersArray : markersArrayNoStart;\n      markerClusterer = new MarkerClusterer(map, markers, {\n        gridSize: clusterSize,\n        maxZoom: clusterZoom\n      });\n    }\n  }\n  /**\r\n   * Add a new marker to the map based on the provided location (latlng).\r\n   *\r\n   * @since  1.0.0\r\n   * @param  {object}  latLng\t\t    The coordinates\r\n   * @param  {number}  storeId\t\tThe store id\r\n   * @param  {object}  infoWindowData The data we need to show in the info window\r\n   * @param  {boolean} draggable      Should the marker be draggable\r\n   * @param  {object}  infoWindow     The infoWindow object\r\n   * @return {void}\r\n   */\n\n\n  function addMarker(latLng, storeId, infoWindowData, draggable, infoWindow) {\n    var url,\n        mapIcon,\n        marker,\n        keepStartMarker = true;\n\n    if (storeId === 0) {\n      infoWindowData = {\n        store: wpslLabels.startPoint\n      };\n      url = markerSettings.url + wpslSettings.startMarker;\n    } else if (typeof infoWindowData.alternateMarkerUrl !== \"undefined\" && infoWindowData.alternateMarkerUrl) {\n      url = infoWindowData.alternateMarkerUrl;\n    } else if (typeof infoWindowData.categoryMarkerUrl !== \"undefined\" && infoWindowData.categoryMarkerUrl) {\n      url = infoWindowData.categoryMarkerUrl;\n    } else {\n      url = markerSettings.url + wpslSettings.storeMarker;\n    }\n\n    mapIcon = {\n      url: url,\n      scaledSize: new google.maps.Size(Number(markerSettings.scaledSize[0]), Number(markerSettings.scaledSize[1])),\n      //retina format\n      origin: new google.maps.Point(Number(markerSettings.origin[0]), Number(markerSettings.origin[1])),\n      anchor: new google.maps.Point(Number(markerSettings.anchor[0]), Number(markerSettings.anchor[1]))\n    };\n    marker = new google.maps.Marker({\n      position: latLng,\n      map: map,\n      optimized: false,\n      //fixes markers flashing while bouncing\n      title: decodeHtmlEntity(infoWindowData.store),\n      draggable: draggable,\n      storeId: storeId,\n      icon: mapIcon\n    }); // Store the marker for later use.\n\n    markersArray.push(marker);\n    google.maps.event.addListener(marker, \"click\", function (currentMap) {\n      return function () {\n        // The start marker will have a store id of 0, all others won't.\n        if (storeId != 0) {\n          // Check if streetview is available at the clicked location.\n          if (typeof wpslSettings.markerStreetView !== \"undefined\" && wpslSettings.markerStreetView == 1) {\n            checkStreetViewStatus(latLng, function () {\n              setInfoWindowContent(marker, createInfoWindowHtml(infoWindowData), infoWindow, currentMap);\n            });\n          } else {\n            setInfoWindowContent(marker, createInfoWindowHtml(infoWindowData), infoWindow, currentMap);\n          }\n        } else {\n          setInfoWindowContent(marker, wpslLabels.startPoint, infoWindow, currentMap);\n        }\n\n        google.maps.event.clearListeners(infoWindow, \"domready\");\n        google.maps.event.addListener(infoWindow, \"domready\", function () {\n          infoWindowClickActions(marker, currentMap);\n          checkMaxZoomLevel();\n        });\n      };\n    }(map)); // Only the start marker will be draggable.\n\n    if (draggable) {\n      google.maps.event.addListener(marker, \"dragend\", function (event) {\n        deleteOverlays(keepStartMarker);\n        map.setCenter(event.latLng);\n        reverseGeocode(event.latLng);\n        findStoreLocations(event.latLng, resetMap, autoLoad = false, infoWindow);\n      });\n    }\n  }\n  /**\r\n   * Decode HTML entities.\r\n   *\r\n   * @link\thttps://gist.github.com/CatTail/4174511\r\n   * @since\t2.0.4\r\n   * @param\t{string} str The string to decode.\r\n   * @returns {string} The string with the decoded HTML entities.\r\n   */\n\n\n  function decodeHtmlEntity(str) {\n    if (str) {\n      return str.replace(/&#(\\d+);/g, function (match, dec) {\n        return String.fromCharCode(dec);\n      });\n    }\n  } // Check if we are using both the infobox for the info windows and have marker clusters.\n\n\n  if (typeof wpslSettings.infoWindowStyle !== \"undefined\" && wpslSettings.infoWindowStyle == \"infobox\" && wpslSettings.markerClusters == 1) {\n    var clusters, clusterLen, markerLen, i, j;\n    /*\r\n     * We need to listen to both zoom_changed and idle.\r\n     *\r\n     * If the zoom level changes, then the marker clusters either merges nearby\r\n     * markers, or changes into individual markers. Which is the moment we\r\n     * either show or hide the opened info window.\r\n     *\r\n     * \"idle\" is necessary to make sure the getClusters() is up\r\n     * to date with the correct cluster data.\r\n     */\n\n    google.maps.event.addListener(map, \"zoom_changed\", function () {\n      google.maps.event.addListenerOnce(map, \"idle\", function () {\n        if (typeof markerClusterer !== \"undefined\") {\n          clusters = markerClusterer.clusters_;\n\n          if (clusters.length) {\n            for (i = 0, clusterLen = clusters.length; i < clusterLen; i++) {\n              for (j = 0, markerLen = clusters[i].markers_.length; j < markerLen; j++) {\n                /*\r\n                 * Match the storeId from the cluster marker with the\r\n                 * marker id that was set when the info window was opened\r\n                 */\n                if (clusters[i].markers_[j].storeId == activeWindowMarkerId) {\n                  /*\r\n                   * If there is a visible info window, but the markers_[j].map is null ( hidden )\r\n                   * it means the info window belongs to a marker that is part of a marker cluster.\r\n                   *\r\n                   * If that is the case then we hide the info window ( the individual marker isn't visible ).\r\n                   *\r\n                   * The default info window script handles this automatically, but the\r\n                   * infobox library in combination with the marker clusters doesn't.\r\n                   */\n                  if (infoWindow.getVisible() && clusters[i].markers_[j].map === null) {\n                    infoWindow.setVisible(false);\n                  } else if (!infoWindow.getVisible() && clusters[i].markers_[j].map !== null) {\n                    infoWindow.setVisible(true);\n                  }\n\n                  break;\n                }\n              }\n            }\n          }\n        }\n      });\n    });\n  }\n  /**\r\n   * Set the correct info window content for the marker.\r\n   *\r\n   * @since\t1.2.20\r\n   * @param\t{object} marker\t\t\t   Marker data\r\n   * @param\t{string} infoWindowContent The infoWindow content\r\n   * @param\t{object} infoWindow\t\t   The infoWindow object\r\n   * @param\t{object} currentMap\t\t   The map object\r\n   * @returns {void}\r\n   */\n\n\n  function setInfoWindowContent(marker, infoWindowContent, infoWindow, currentMap) {\n    openInfoWindow.length = 0;\n    infoWindow.setContent(infoWindowContent);\n    infoWindow.open(currentMap, marker);\n    openInfoWindow.push(infoWindow);\n    /*\r\n     * Store the marker id if both the marker clusters and the infobox are enabled.\r\n     *\r\n     * With the normal info window script the info window is automatically closed\r\n     * once a user zooms out, and the marker clusters are enabled,\r\n     * but this doesn't happen with the infobox library.\r\n     *\r\n     * So we need to show/hide it manually when the user zooms out,\r\n     * and for this to work we need to know which marker to target.\r\n     */\n\n    if (typeof wpslSettings.infoWindowStyle !== \"undefined\" && wpslSettings.infoWindowStyle == \"infobox\" && wpslSettings.markerClusters == 1) {\n      activeWindowMarkerId = marker.storeId;\n      infoWindow.setVisible(true);\n    }\n  }\n  /**\r\n   * Handle clicks for the different info window actions like,\r\n   * direction, streetview and zoom here.\r\n   *\r\n   * @since\t1.2.20\r\n   * @param\t{object} marker\t\tHolds the marker data\r\n   * @param\t{object} currentMap\tThe map object\r\n   * @returns {void}\r\n   */\n\n\n  function infoWindowClickActions(marker, currentMap) {\n    $(\".wpsl-info-actions a\").on(\"click\", function (e) {\n      var maxZoom = Number(wpslSettings.autoZoomLevel);\n      e.stopImmediatePropagation();\n\n      if ($(this).hasClass(\"wpsl-directions\")) {\n        /*\r\n         * Check if we need to show the direction on the map\r\n         * or send the users to maps.google.com\r\n         */\n        if (wpslSettings.directionRedirect == 1) {\n          return true;\n        } else {\n          renderDirections($(this));\n        }\n      } else if ($(this).hasClass(\"wpsl-streetview\")) {\n        activateStreetView(marker, currentMap);\n      } else if ($(this).hasClass(\"wpsl-zoom-here\")) {\n        currentMap.setCenter(marker.getPosition());\n        currentMap.setZoom(maxZoom);\n      }\n\n      return false;\n    });\n  }\n  /**\r\n   * Check if have reached the max auto zoom level.\r\n   *\r\n   * If so we hide the 'Zoom here' text in the info window,\r\n   * otherwise we show it.\r\n   *\r\n   * @since\t2.0.0\r\n   * @returns {void}\r\n   */\n\n\n  function checkMaxZoomLevel() {\n    var zoomLevel = map.getZoom();\n\n    if (zoomLevel >= wpslSettings.autoZoomLevel) {\n      $(\".wpsl-zoom-here\").hide();\n    } else {\n      $(\".wpsl-zoom-here\").show();\n    }\n  }\n  /**\r\n   * Activate streetview for the clicked location.\r\n   *\r\n   * @since\t1.2.20\r\n   * @param\t{object} marker\t    The current marker\r\n   * @param\t{object} currentMap The map object\r\n   * @returns {void}\r\n   */\n\n\n  function activateStreetView(marker, currentMap) {\n    var panorama = currentMap.getStreetView();\n    panorama.setPosition(marker.getPosition());\n    panorama.setVisible(true);\n    $(\"#wpsl-map-controls\").hide();\n    StreetViewListener(panorama, currentMap);\n  }\n  /**\r\n   * Listen for changes in the streetview visibility.\r\n   *\r\n   * Sometimes the infowindow offset is incorrect after switching back from streetview.\r\n   * We fix this by zooming in and out. If someone has a better fix, then let me know at\r\n   * info at tijmensmit.com\r\n   *\r\n   * @since\t1.2.20\r\n   * @param\t{object} panorama   The streetview object\r\n   * @param\t{object} currentMap The map object\r\n   * @returns {void}\r\n   */\n\n\n  function StreetViewListener(panorama, currentMap) {\n    google.maps.event.addListener(panorama, \"visible_changed\", function () {\n      if (!panorama.getVisible()) {\n        var currentZoomLevel = currentMap.getZoom();\n        $(\"#wpsl-map-controls\").show();\n        currentMap.setZoom(currentZoomLevel - 1);\n        currentMap.setZoom(currentZoomLevel);\n      }\n    });\n  }\n  /**\r\n   * Check the streetview status.\r\n   *\r\n   * Make sure that a streetview exists for\r\n   * the latlng for the open info window.\r\n   *\r\n   * @since\t1.2.20\r\n   * @param\t{object}   latLng The latlng coordinates\r\n   * @param\t{callback} callback\r\n   * @returns {void}\r\n   */\n\n\n  function checkStreetViewStatus(latLng, callback) {\n    var service = new google.maps.StreetViewService();\n    service.getPanoramaByLocation(latLng, 50, function (result, status) {\n      streetViewAvailable = status == google.maps.StreetViewStatus.OK ? true : false;\n      callback();\n    });\n  }\n  /**\r\n   * Helper methods for the underscore templates.\r\n   *\r\n   * @link\t http://underscorejs.org/#template\r\n   * @requires underscore.js\r\n   * @todo move it to another JS file to make it accessible for add-ons?\r\n   * @since\t 2.0.0\r\n   */\n\n\n  var templateHelpers = {\n    /**\r\n     * Make the phone number clickable if we are dealing with a mobile useragent.\r\n     *\r\n     * @since\t1.2.20\r\n     * @param\t{string} phoneNumber The phone number\r\n     * @returns {string} phoneNumber Either just the plain number, or with a link wrapped around it with tel:\r\n     */\n    formatPhoneNumber: function (phoneNumber) {\n      if (wpslSettings.phoneUrl == 1 && checkMobileUserAgent() || wpslSettings.clickableDetails == 1) {\n        phoneNumber = \"<a href='tel:\" + templateHelpers.formatClickablePhoneNumber(phoneNumber) + \"'>\" + phoneNumber + \"</a>\";\n      }\n\n      return phoneNumber;\n    },\n\n    /**\r\n     * Replace spaces - . and () from phone numbers.\r\n     * Also if the number starts with a + we check for a (0) and remove it.\r\n     *\r\n     * @since\t1.2.20\r\n     * @param\t{string} phoneNumber The phone number\r\n     * @returns {string} phoneNumber The 'cleaned' number\r\n     */\n    formatClickablePhoneNumber: function (phoneNumber) {\n      if (phoneNumber.indexOf(\"+\") != -1 && phoneNumber.indexOf(\"(0)\") != -1) {\n        phoneNumber = phoneNumber.replace(\"(0)\", \"\");\n      }\n\n      return phoneNumber.replace(/(-| |\\(|\\)|\\.|)/g, \"\");\n    },\n\n    /**\r\n     * Check if we need to make the email address clickable.\r\n     *\r\n     * @since 2.2.13\r\n     * @param   {string} email The email address\r\n     * @returns {string} email Either the normal email address, or the clickable version.\r\n     */\n    formatEmail: function (email) {\n      if (wpslSettings.clickableDetails == 1) {\n        email = \"<a href='mailto:\" + email + \"'>\" + email + \"</a>\";\n      }\n\n      return email;\n    },\n\n    /**\r\n     * Create the html for the info window action.\r\n     *\r\n     * @since\t2.0.0\r\n     * @param\t{string} id\t\tThe store id\r\n     * @returns {string} output The html for the info window actions\r\n     */\n    createInfoWindowActions: function (id) {\n      var output,\n          streetView = \"\",\n          zoomTo = \"\";\n\n      if ($(\"#wpsl-gmap\").length) {\n        if (streetViewAvailable) {\n          streetView = \"<a class='wpsl-streetview' href='#'>\" + wpslLabels.streetView + \"</a>\";\n        }\n\n        if (wpslSettings.markerZoomTo == 1) {\n          zoomTo = \"<a class='wpsl-zoom-here' href='#'>\" + wpslLabels.zoomHere + \"</a>\";\n        }\n\n        output = \"<div class='wpsl-info-actions'>\" + templateHelpers.createDirectionUrl(id) + streetView + zoomTo + \"</div>\";\n      }\n\n      return output;\n    },\n\n    /**\r\n     * Create the url that takes the user to the maps.google.com page\r\n     * and shows the correct driving directions.\r\n     *\r\n     * @since\t1.0.0\r\n     * @param\t{string} id\t\t\t  The store id\r\n     * @returns {string} directionUrl The full maps.google.com url with the encoded start + end address\r\n     */\n    createDirectionUrl: function (id) {\n      var directionUrl,\n          destinationAddress,\n          zip,\n          url = {};\n\n      if (wpslSettings.directionRedirect == 1) {\n        // If we somehow failed to determine the start address, just set it to empty.\n        if (typeof startAddress === \"undefined\") {\n          startAddress = \"\";\n        }\n\n        url.target = \"target='_blank'\"; // If the id exists the user clicked on a marker we get the direction url from the search results.\n\n        if (typeof id !== \"undefined\") {\n          url.src = $(\"[data-store-id=\" + id + \"] .wpsl-directions\").attr(\"href\");\n        } else {\n          // Only add a , after the zip if the zip value exists.\n          if (this.zip) {\n            zip = this.zip + \", \";\n          } else {\n            zip = \"\";\n          }\n\n          destinationAddress = this.address + \", \" + this.city + \", \" + zip + this.country;\n          url.src = \"https://www.google.com/maps/dir/?api=1&origin=\" + templateHelpers.rfc3986EncodeURIComponent(startAddress) + \"&destination=\" + templateHelpers.rfc3986EncodeURIComponent(destinationAddress) + \"&travelmode=\" + wpslSettings.directionsTravelMode.toLowerCase() + \"\";\n        }\n      } else {\n        url = {\n          src: \"#\",\n          target: \"\"\n        };\n      }\n\n      directionUrl = \"<a class='wpsl-directions' \" + url.target + \" href='\" + url.src + \"'>\" + wpslLabels.directions + \"</a>\";\n      return directionUrl;\n    },\n\n    /**\r\n     * Make the URI encoding compatible with RFC 3986.\r\n     *\r\n     * !, ', (, ), and * will be escaped, otherwise they break the string.\r\n     *\r\n     * @since\t1.2.20\r\n     * @param\t{string} str The string to encode\r\n     * @returns {string} The encoded string\r\n     */\n    rfc3986EncodeURIComponent: function (str) {\n      return encodeURIComponent(str).replace(/[!'()*]/g, escape);\n    }\n  };\n  /**\r\n   * Create the HTML template used in the info windows on the map.\r\n   *\r\n   * @since\t1.0.0\r\n   * @param\t{object} infoWindowData\tThe data that is shown in the info window (address, url, phone etc)\r\n   * @returns {string} windowContent\tThe HTML content that is placed in the info window\r\n   */\n\n  function createInfoWindowHtml(infoWindowData) {\n    var windowContent, template;\n\n    if ($(\"#wpsl-base-gmap_0\").length) {\n      template = $(\"#wpsl-cpt-info-window-template\").html();\n    } else {\n      template = $(\"#wpsl-info-window-template\").html();\n    }\n\n    windowContent = _.template(template)(infoWindowData); //see http://underscorejs.org/#template\n\n    return windowContent;\n  }\n  /**\r\n   * Zoom the map so that all markers fit in the window.\r\n   *\r\n   * @since\t1.0.0\r\n   * @returns {void}\r\n   */\n\n\n  function fitBounds() {\n    var i,\n        markerLen,\n        maxZoom = Number(wpslSettings.autoZoomLevel),\n        bounds = new google.maps.LatLngBounds(); // Make sure we don't zoom to far.\n\n    attachBoundsChangedListener(map, maxZoom);\n\n    for (i = 0, markerLen = markersArray.length; i < markerLen; i++) {\n      bounds.extend(markersArray[i].position);\n    }\n\n    map.fitBounds(bounds);\n  }\n  /**\r\n   * Remove all existing markers from the map.\r\n   *\r\n   * @since\t1.0.0\r\n   * @param\t{boolean} keepStartMarker Whether or not to keep the start marker while removing all the other markers from the map\r\n   * @returns {void}\r\n   */\n\n\n  function deleteOverlays(keepStartMarker) {\n    var markerLen, i;\n    directionsDisplay.setMap(null); // Remove all the markers from the map, and empty the array.\n\n    if (markersArray) {\n      for (i = 0, markerLen = markersArray.length; i < markerLen; i++) {\n        // Check if we need to keep the start marker, or remove everything.\n        if (keepStartMarker) {\n          if (markersArray[i].draggable != true) {\n            markersArray[i].setMap(null);\n          } else {\n            startMarkerData = markersArray[i];\n          }\n        } else {\n          markersArray[i].setMap(null);\n        }\n      }\n\n      markersArray.length = 0;\n    } // If marker clusters exist, remove them from the map.\n\n\n    if (markerClusterer) {\n      markerClusterer.clearMarkers();\n    }\n  }\n  /**\r\n   * Handle the geocode errors.\r\n   *\r\n   * @since\t1.0.0\r\n   * @param   {string} status Contains the error code\r\n   * @returns {void}\r\n   */\n\n\n  function geocodeErrors(status) {\n    var msg;\n\n    switch (status) {\n      case \"ZERO_RESULTS\":\n        msg = wpslLabels.noResults;\n        break;\n\n      case \"OVER_QUERY_LIMIT\":\n        msg = wpslLabels.queryLimit;\n        break;\n\n      default:\n        msg = wpslLabels.generalError;\n        break;\n    }\n\n    alert(msg);\n  }\n  /**\r\n   * Handle the driving direction errors.\r\n   *\r\n   * @since   1.2.20\r\n   * @param   {string} status Contains the error code\r\n   * @returns {void}\r\n   */\n\n\n  function directionErrors(status) {\n    var msg;\n\n    switch (status) {\n      case \"NOT_FOUND\":\n      case \"ZERO_RESULTS\":\n        msg = wpslLabels.noDirectionsFound;\n        break;\n\n      case \"OVER_QUERY_LIMIT\":\n        msg = wpslLabels.queryLimit;\n        break;\n\n      default:\n        msg = wpslLabels.generalError;\n        break;\n    }\n\n    alert(msg);\n  }\n\n  $(\"#wpsl-stores\").on(\"click\", \".wpsl-store-details\", function () {\n    var i,\n        len,\n        $parentLi = $(this).parents(\"li\"),\n        storeId = $parentLi.data(\"store-id\"); // Check if we should show the 'more info' details.\n\n    if (wpslSettings.moreInfoLocation == \"info window\") {\n      for (i = 0, len = markersArray.length; i < len; i++) {\n        if (markersArray[i].storeId == storeId) {\n          google.maps.event.trigger(markersArray[i], \"click\");\n        }\n      }\n    } else {\n      // Check if we should set the 'more info' item to active or not.\n      if ($parentLi.find(\".wpsl-more-info-listings\").is(\":visible\")) {\n        $(this).removeClass(\"wpsl-active-details\");\n      } else {\n        $(this).addClass(\"wpsl-active-details\");\n      }\n\n      $parentLi.siblings().find(\".wpsl-store-details\").removeClass(\"wpsl-active-details\");\n      $parentLi.siblings().find(\".wpsl-more-info-listings\").hide();\n      $parentLi.find(\".wpsl-more-info-listings\").toggle();\n    }\n    /*\r\n     * If we show the store listings under the map, we do want to jump to the\r\n     * top of the map to focus on the opened infowindow\r\n     */\n\n\n    if (wpslSettings.templateId != \"default\" || wpslSettings.moreInfoLocation == \"store listings\") {\n      return false;\n    }\n  });\n  /**\r\n   * Create the styled dropdown filters.\r\n   *\r\n   * Inspired by https://github.com/patrickkunka/easydropdown\r\n   *\r\n   * @since\t1.2.24\r\n   * @returns {void}\r\n   */\n\n  function createDropdowns() {\n    $(\"#wpsl-radius-dropdown\").css(\"border-color\", \" \");\n    $(\"#wpsl-results-dropdown\").css(\"border-color\", \"\");\n    var maxDropdownHeight = Number(wpslSettings.maxDropdownHeight);\n    $(\".wpsl-dropdown\").each(function (index) {\n      var active,\n          maxHeight,\n          $this = $(this);\n      $this.$dropdownWrap = $this.wrap(\"<div class='wpsl-dropdown'></div>\").parent();\n      $this.$selectedVal = $this.val();\n      $this.$dropdownElem = $(\"<div><ul/></div>\").appendTo($this.$dropdownWrap);\n      $this.$dropdown = $this.$dropdownElem.find(\"ul\");\n      $this.$options = $this.$dropdownWrap.find(\"option\"); // Hide the original <select> and remove the css class.\n\n      $this.hide().removeClass(\"wpsl-dropdown\"); // Loop over the options from the <select> and move them to a <li> instead.\n\n      $.each($this.$options, function () {\n        if ($(this).val() == $this.$selectedVal) {\n          active = 'class=\"wpsl-selected-dropdown\"';\n        } else {\n          active = \"\";\n        }\n\n        $this.$dropdown.append(\"<li data-value=\" + $(this).val() + \" \" + active + \">\" + $(this).text() + \"</li>\");\n      });\n      $this.$dropdownElem.before(\"<span data-value=\" + $this.find(\":selected\").val() + \" class='wpsl-selected-item'>\" + $this.find(\":selected\").text() + \"</span>\");\n      $this.$dropdownItem = $this.$dropdownElem.find(\"li\"); // Listen for clicks on the 'wpsl-dropdown' div.\n\n      $this.$dropdownWrap.on(\"click\", function (e) {\n        // Check if we only need to close the current open dropdown.\n        if ($(this).hasClass(\"wpsl-active\")) {\n          $(this).removeClass(\"wpsl-active\");\n          return;\n        }\n\n        closeAllDropdowns();\n        $(this).toggleClass(\"wpsl-active\");\n        maxHeight = 0; // Either calculate the correct height for the <ul>, or set it to 0 to hide it.\n\n        if ($(this).hasClass(\"wpsl-active\")) {\n          $this.$dropdownItem.each(function (index) {\n            maxHeight += $(this).outerHeight();\n          });\n          $this.$dropdownElem.css(\"height\", maxHeight + 2 + \"px\");\n        } else {\n          $this.$dropdownElem.css(\"height\", 0);\n        } // Check if we need to enable the scrollbar in the dropdown filter.\n\n\n        if (maxHeight > maxDropdownHeight) {\n          $(this).addClass(\"wpsl-scroll-required\");\n          $this.$dropdownElem.css(\"height\", maxDropdownHeight + \"px\");\n        }\n\n        e.stopPropagation();\n      }); // Listen for clicks on the individual dropdown items.\n\n      $this.$dropdownItem.on(\"click\", function (e) {\n        // Set the correct value as the selected item.\n        $this.$dropdownWrap.find($(\".wpsl-selected-item\")).html($(this).text()).attr(\"data-value\", $(this).attr(\"data-value\")); // Apply the class to the correct item to make it bold.\n\n        $this.$dropdownItem.removeClass(\"wpsl-selected-dropdown\");\n        $(this).addClass(\"wpsl-selected-dropdown\");\n        closeAllDropdowns();\n        e.stopPropagation();\n      });\n    });\n    $(document).click(function () {\n      closeAllDropdowns();\n    });\n  }\n  /**\r\n   * Close all the dropdowns.\r\n   *\r\n   * @since\t1.2.24\r\n   * @returns {void}\r\n   */\n\n\n  function closeAllDropdowns() {\n    $(\".wpsl-dropdown\").removeClass(\"wpsl-active\");\n    $(\".wpsl-dropdown div\").css(\"height\", 0);\n  }\n  /**\r\n   * Check if the user submitted a search through a search widget.\r\n   *\r\n   * @since\t2.1.0\r\n   * @returns {void}\r\n   */\n\n\n  function checkWidgetSubmit() {\n    if ($(\".wpsl-search\").hasClass(\"wpsl-widget\")) {\n      $(\"#wpsl-search-btn\").trigger(\"click\");\n      $(\".wpsl-search\").removeClass(\"wpsl-widget\");\n    }\n  }\n  /**\r\n   * Check if we need to run the code to prevent Google Maps\r\n   * from showing up grey when placed inside one or more tabs.\r\n   *\r\n   * @since 2.2.10\r\n   * @return {void}\r\n   */\n\n\n  function maybeApplyTabFix() {\n    var mapNumber, len;\n\n    if (_.isArray(wpslSettings.mapTabAnchor)) {\n      for (mapNumber = 0, len = mapsArray.length; mapNumber < len; mapNumber++) {\n        fixGreyTabMap(mapsArray[mapNumber], wpslSettings.mapTabAnchor[mapNumber], mapNumber);\n      }\n    } else if ($(\"a[href='#\" + wpslSettings.mapTabAnchor + \"']\").length) {\n      fixGreyTabMap(map, wpslSettings.mapTabAnchor);\n    }\n  }\n  /**\r\n   * This code prevents the map from showing a large grey area if\r\n   * the store locator is placed in a tab, and that tab is actived.\r\n   *\r\n   * The default map anchor is set to 'wpsl-map-tab', but you can\r\n   * change this with the 'wpsl_map_tab_anchor' filter.\r\n   *\r\n   * Note: If the \"Attempt to auto-locate the user\" option is enabled,\r\n   * and the user quickly switches to the store locator tab, before the\r\n   * Geolocation timeout is reached, then the map is sometimes centered in the ocean.\r\n   *\r\n   * I haven't really figured out why this happens. The only option to fix this\r\n   * is to simply disable the \"Attempt to auto-locate the user\" option if\r\n   * you use the store locator in a tab.\r\n   *\r\n   * @since   2.2.10\r\n   * @param   {object} currentMap\t  The map object from the current map\r\n   * @param   {string} mapTabAnchor The anchor used in the tab that holds the map\r\n   * @param \t(int) \t mapNumber    Map number\r\n   * @link    http://stackoverflow.com/questions/9458215/google-maps-not-working-in-jquery-tabs\r\n   * @returns {void}\r\n   */\n\n\n  function fixGreyTabMap(currentMap, mapTabAnchor, mapNumber) {\n    var mapZoom,\n        mapCenter,\n        maxZoom,\n        bounds,\n        tabMap,\n        returnBool = Number(wpslSettings.mapTabAnchorReturn) ? true : false,\n        $wpsl_tab = $(\"a[href='#\" + mapTabAnchor + \"']\");\n\n    if (typeof currentMap.maxZoom !== \"undefined\") {\n      maxZoom = currentMap.maxZoom;\n    } else {\n      maxZoom = Number(wpslSettings.autoZoomLevel);\n    }\n    /*\r\n     * We need to do this to prevent the map from flashing if\r\n     * there's only a single marker on the first click on the tab.\r\n     */\n\n\n    if (typeof mapNumber !== \"undefined\" && mapNumber == 0) {\n      $wpsl_tab.addClass(\"wpsl-fitbounds\");\n    }\n\n    $wpsl_tab.on(\"click\", function () {\n      setTimeout(function () {\n        if (typeof currentMap.map !== \"undefined\") {\n          bounds = currentMap.bounds;\n          tabMap = currentMap.map;\n        } else {\n          tabMap = currentMap;\n        }\n\n        mapZoom = tabMap.getZoom();\n        mapCenter = tabMap.getCenter();\n        google.maps.event.trigger(tabMap, \"resize\");\n\n        if (!$wpsl_tab.hasClass(\"wpsl-fitbounds\")) {\n          //Make sure fitBounds doesn't zoom past the max zoom level.\n          attachBoundsChangedListener(tabMap, maxZoom);\n          tabMap.setZoom(mapZoom);\n          tabMap.setCenter(mapCenter);\n\n          if (typeof bounds !== \"undefined\") {\n            tabMap.fitBounds(bounds);\n          } else {\n            fitBounds();\n          }\n\n          $wpsl_tab.addClass(\"wpsl-fitbounds\");\n        }\n      }, 50);\n      return returnBool;\n    });\n  }\n  /**\r\n   * Add the bounds_changed event listener to the map object\r\n   * to make sure we don't zoom past the max zoom level.\r\n   *\r\n   * @since 2.2.10\r\n   * @param object The map object to attach the event listener to\r\n   * @returns {void}\r\n   */\n\n\n  function attachBoundsChangedListener(map, maxZoom) {\n    google.maps.event.addListenerOnce(map, \"bounds_changed\", function () {\n      google.maps.event.addListenerOnce(map, \"idle\", function () {\n        if (this.getZoom() > maxZoom) {\n          this.setZoom(maxZoom);\n        }\n      });\n    });\n  }\n  /**\r\n   * Handle keyboard submits when the autocomplete option is enabled.\r\n   *\r\n   * If we don't do this, then the search will break the second time\r\n   * the user makes a search, selects the item with the keyboard\r\n   * and submits it with the enter key.\r\n   *\r\n   * @since 2.2.20\r\n   * @returns {void}\r\n   */\n\n\n  function keyboardAutoCompleteSubmit() {\n    $(\"#wpsl-search-input\").keypress(function (e) {\n      if (e.which == 13) {\n        if (selectedEmptyInput()) {\n          return;\n        }\n\n        resetSearchResults();\n        codeAddress(infoWindow);\n        return false;\n      }\n    });\n  }\n  /**\r\n   * Reset all elements before a search is made.\r\n   *\r\n   * @since 2.2.20\r\n   * @returns {void}\r\n   */\n\n\n  function resetSearchResults() {\n    var keepStartMarker = false;\n    $(\"#wpsl-result-list ul\").empty();\n    $(\"#wpsl-stores\").show();\n    $(\".wpsl-direction-before, .wpsl-direction-after\").remove();\n    $(\"#wpsl-direction-details\").hide();\n    resetMap = false; // Force the open InfoBox info window to close.\n\n    closeInfoBoxWindow();\n    deleteOverlays(keepStartMarker);\n    deleteStartMarker();\n  }\n  /* -------------------Fleetwood specific code-------------------------------*/\n\n  /* insertDefaultOption appends the option select to the dropdown menu*/\n\n  /*This function is dependent on the wp-admin page where users can select the default options that appear on teh front end.*/\n\n  /*User must have option of 0 and have that selected as the default option when page loads. Yuk!*/\n\n\n  function insertDefaultOption() {\n    if ($(\".wpsl-mobile\").length) {\n      $(\"#wpsl-radius-dropdown > option\").each(function () {\n        if ($(this).val() === \"0\") {\n          $(this).text(\"Select\");\n        }\n      });\n      $(\"#wpsl-results-dropdown > option\").each(function () {\n        if ($(this).val() === \"0\") {\n          $(this).text(\"Select\");\n        }\n      });\n    } else if ($(\".wpsl-dropdown\").length) {\n      $(\".wpsl-dropdown\").each(function (index) {\n        var active,\n            maxHeight,\n            $this = $(this);\n        $this.$dropdownWrap = $this.wrap(\"<div class='wpsl-dropdown'></div>\").parent();\n        $this.$dropdownElem = $(\"<div><ul/></div>\").appendTo($this.$dropdownWrap);\n        $this.$selectedVal = $this.val();\n        $this.$dropdown = $this.$dropdownElem.find(\"ul\");\n        $this.$options = $this.$dropdownWrap.find(\"option\");\n      });\n      $(\"#wpsl-radius-dropdown > option\").each(function () {\n        \"0\" === $(this).val() && $(this).text(\"Select\");\n      });\n      $(\"#wpsl-results-dropdown > option\").each(function () {\n        \"0\" === $(this).val() && $(this).text(\"Select\");\n      });\n    }\n  }\n  /*\r\n    Is used to check weather the input for search radius or results are zero\r\n    */\n\n\n  function selectedEmptyInput() {\n    let emptySelect = false;\n\n    if ($(\"span.wpsl-selected-item\").length) {\n      $(\"span.wpsl-selected-item\").each(function () {\n        if (!parseInt($(this).attr(\"data-value\"))) {\n          emptySelect = true;\n        }\n\n        return;\n      });\n    } else {\n      if (!parseInt($(\"#wpsl-radius-dropdown\").val()) || !parseInt($(\"#wpsl-results-dropdown\").val())) {\n        emptySelect = true;\n      }\n    }\n\n    return emptySelect;\n  } //\n  //     /*\n  //     Opens the radius dropdown menu on desktop devices only\n  //      */\n  //\n\n\n  $(\"#wpsl-search-input\").change(function () {\n    if (!checkMobileUserAgent()) {\n      var isSearch = $(\"#wpsl-search-input\").val();\n      var radiusSelected = 0;\n\n      if ($(\"#wpsl-radius span.wpsl-selected-item\").attr(\"data-value\")) {\n        radiusSelected = parseInt($(\"#wpsl-radius span.wpsl-selected-item\").attr(\"data-value\"));\n      } else {\n        radiusSelected = parseInt($(\"#wpsl-radius-dropdown\").val());\n      }\n\n      if (isSearch && radiusSelected === 0 && !checkMobileUserAgent()) {\n        $(\"#wpsl-radius span.wpsl-selected-item\").click();\n      } else {\n        $(\"#wpsl-results select.wpsl-dropdown\").focus();\n      }\n    }\n  }); //simulate a click on desktop devices only.\n\n  $(\"#wpsl-radius ul li\").click(function (e) {\n    if (!checkMobileUserAgent()) {\n      var radiusSelected = parseInt($(\"#wpsl-radius span.wpsl-selected-item\").attr(\"data-value\"));\n      var isSearch = $(\"#wpsl-search-input\").val();\n\n      if (radiusSelected !== 0 && isSearch && !checkMobileUserAgent()) {\n        $(\"#wpsl-results span.wpsl-selected-item\").click();\n      }\n    }\n  });\n\n  function removeDangerBorder(el) {\n    $(el).css(\"border-color\", \"\");\n  }\n\n  function addDangerBorder() {\n    if (checkMobileUserAgent()) {\n      var radiusDropdown = parseInt($(\"#wpsl-radius-dropdown\").val());\n      var resultsDropdown = parseInt($(\"#wpsl-results-dropdown\").val());\n\n      if (!radiusDropdown) {\n        $(\"#wpsl-radius-dropdown\").css(\"border-color\", \"red\");\n      }\n\n      if (!resultsDropdown) {\n        $(\"#wpsl-results-dropdown\").css(\"border-color\", \"red\");\n      }\n    }\n  }\n});\n\n//# sourceURL=webpack://wp_store_plugin/./js/wpsl-gmap.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./js/wpsl-gmap.js"]();
/******/ 	
/******/ })()
;